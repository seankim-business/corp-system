# AR (Agent Resource) Management System - Comprehensive Implementation Plan

> **Generated by:** Prometheus (Planner Agent)
> **Date:** 2026-01-30
> **Status:** ITERATION 2 - CRITIC FEEDBACK ADDRESSED
> **Complexity:** HIGH - Enterprise-grade multi-module system
> **Revision:** Fixed critical gaps identified by Critic review

---

## Executive Summary

The AR Management System extends Nubabel's existing multi-agent orchestration infrastructure to provide **enterprise-grade Agent Resource management**. This system mirrors human HR practices but adapted for AI agents, enabling:

1. **Agent Organization Structure** - Hierarchical teams with clear R&R
2. **Human-in-the-Loop Integration** - Approval workflows across all organizational levels
3. **Autonomous Coordination** - Daily reports, goal alignment, priority adjustment
4. **Schedule Management** - Calendar integration, meeting coordination, availability
5. **Dynamic Team Composition** - Industry best practices-based team templates
6. **AR Department Self-Management** - Meta-agents managing the AR system itself

---

## Context

### Existing Infrastructure Leveraged

| Component | Location | Reuse Strategy |
|-----------|----------|----------------|
| Agent Model | `prisma/schema.prisma` | Extend with AR-specific fields |
| Approval System | `src/services/approval-checker.ts`, `auto-approval.service.ts` | Extend for multi-level approval |
| Delegation Service | `src/services/delegation-service.ts` | Extend for agent-to-human delegation |
| Orchestrator | `src/orchestrator/` | Add AR-aware routing |
| Google Calendar | `src/mcp-servers/google-calendar/` | Integrate for scheduling |
| Daily Briefing | `src/jobs/daily-briefing.job.ts` | Extend for AR-specific reports |
| RABSIC Model | Task.responsible/accountable/etc | Extend to AgentAssignment |

### Key Design Principles

1. **Separation of Concerns**: AR logic in dedicated modules, not mixed with existing services
2. **Event-Driven Architecture**: AR changes emit events for downstream processing
3. **Multi-Tenant**: All AR data scoped by organizationId
4. **Backward Compatible**: Existing agent/orchestrator functionality preserved
5. **Incremental Rollout**: Feature-flagged modules for gradual deployment

---

## Work Objectives

### Core Objective

Build a production-grade Agent Resource Management System that enables organizations to manage AI agents with the same rigor and structure as human resources.

### Deliverables

| # | Deliverable | Priority | Effort |
|---|-------------|----------|--------|
| D1 | Agent Organization Schema & API | P0 | 3 days |
| D2 | Human-Agent Approval Workflow | P0 | 4 days |
| D3 | Autonomous Coordination Engine | P1 | 4 days |
| D4 | Schedule & Availability System | P1 | 3 days |
| D5 | Dynamic Team Templates | P2 | 3 days |
| D6 | AR Department Self-Management | P2 | 3 days |

### Definition of Done

- [ ] All TypeScript compiles without errors
- [ ] Unit test coverage > 80% for new modules
- [ ] Integration tests for critical workflows
- [ ] API documentation (OpenAPI spec)
- [ ] Database migrations applied successfully
- [ ] Feature flags in place for gradual rollout
- [ ] Slack integration for AR notifications working
- [ ] Performance benchmarks met (< 200ms for critical paths)

---

## Must Have / Must NOT Have

### Must Have (Guardrails)

| Requirement | Rationale |
|-------------|-----------|
| Multi-tenant isolation | AR data must be organization-scoped |
| Audit logging for all AR changes | Compliance and debugging |
| Human override capability | Humans can always intervene |
| Graceful degradation | AR failures shouldn't break orchestration |
| Redis caching for frequent lookups | Performance |
| Feature flags per module | Safe rollout |

### Must NOT Have (Anti-Patterns to Avoid)

| Anti-Pattern | Why to Avoid |
|--------------|--------------|
| Tight coupling to Anthropic API | Must support multiple model providers |
| Hardcoded approval chains | Organizations have different structures |
| Blocking operations in hot paths | Performance impact |
| Direct database writes from agents | Must go through service layer |
| Storing sensitive data unencrypted | Security |
| Mixing AR logic with existing orchestrator | Maintainability |

---

## Module 1: Agent Organization Schema & API

### 1.1 Database Schema Extensions

```prisma
// === NEW MODELS ===

/// Agent Department (Organizational Unit)
model AgentDepartment {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  name           String   @db.VarChar(255)  // "Product Design", "Operations"
  code           String   @db.VarChar(50)   // "PROD-DESIGN", "OPS"
  description    String?  @db.Text
  parentId       String?  @map("parent_id") @db.Uuid  // Hierarchical
  headAgentId    String?  @map("head_agent_id") @db.Uuid  // Department head
  headHumanId    String?  @map("head_human_id") @db.Uuid  // Human owner
  budgetCents    Int?     @map("budget_cents")
  costCenter     String?  @map("cost_center") @db.VarChar(50)
  status         String   @default("active") @db.VarChar(50)
  metadata       Json     @default("{}") @db.JsonB
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  organization   Organization      @relation(fields: [organizationId], references: [id])
  parent         AgentDepartment?  @relation("DepartmentHierarchy", fields: [parentId], references: [id])
  children       AgentDepartment[] @relation("DepartmentHierarchy")
  positions      AgentPosition[]

  @@unique([organizationId, code])
  @@index([organizationId])
  @@index([parentId])
  @@map("agent_departments")
}

/// Agent Position (Role Definition)
model AgentPosition {
  id              String   @id @default(uuid()) @db.Uuid
  organizationId  String   @map("organization_id") @db.Uuid
  departmentId    String   @map("department_id") @db.Uuid
  title           String   @db.VarChar(255)  // "Senior Designer", "Lead Analyst"
  level           Int      @default(1)  // 1=Entry, 2=Mid, 3=Senior, 4=Lead, 5=Head
  reportsToId     String?  @map("reports_to_id") @db.Uuid
  requiredSkills  String[] @db.VarChar(100)
  preferredModel  String?  @map("preferred_model") @db.VarChar(50)  // "opus", "sonnet"
  maxConcurrent   Int      @default(1) @map("max_concurrent")  // How many agents can hold this position
  budgetPerTask   Int?     @map("budget_per_task")  // Token budget
  approvalLevel   Int      @default(0) @map("approval_level")  // 0=none, 1=team, 2=dept, 3=org
  metadata        Json     @default("{}") @db.JsonB
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  organization    Organization    @relation(fields: [organizationId], references: [id])
  department      AgentDepartment @relation(fields: [departmentId], references: [id])
  reportsTo       AgentPosition?  @relation("PositionHierarchy", fields: [reportsToId], references: [id])
  directReports   AgentPosition[] @relation("PositionHierarchy")
  assignments     AgentAssignment[]

  @@index([organizationId])
  @@index([departmentId])
  @@index([reportsToId])
  @@map("agent_positions")
}

/// Agent Assignment (Agent to Position mapping)
model AgentAssignment {
  id             String    @id @default(uuid()) @db.Uuid
  organizationId String    @map("organization_id") @db.Uuid
  agentId        String    @map("agent_id") @db.Uuid
  positionId     String    @map("position_id") @db.Uuid
  humanSupervisor String?  @map("human_supervisor") @db.Uuid  // User who oversees
  assignmentType String    @default("permanent") @db.VarChar(50)  // permanent, temporary, acting
  startDate      DateTime  @default(now()) @map("start_date")
  endDate        DateTime? @map("end_date")
  status         String    @default("active") @db.VarChar(50)  // active, on_leave, suspended
  performanceScore Float?  @map("performance_score")  // 0-100
  workload       Float     @default(1.0)  // 0-1 capacity utilization
  metadata       Json      @default("{}") @db.JsonB
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  organization   Organization  @relation(fields: [organizationId], references: [id])
  agent          Agent         @relation(fields: [agentId], references: [id])
  position       AgentPosition @relation(fields: [positionId], references: [id])

  @@index([organizationId])
  @@index([agentId])
  @@index([positionId])
  @@index([status])
  @@map("agent_assignments")
}

/// AR Cost Tracking
model ARCostEntry {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  agentId        String?  @map("agent_id") @db.Uuid
  departmentId   String?  @map("department_id") @db.Uuid
  costType       String   @db.VarChar(50)  // "token", "api_call", "compute"
  amountCents    Int      @map("amount_cents")
  tokenCount     Int?     @map("token_count")
  modelUsed      String?  @map("model_used") @db.VarChar(50)
  taskReference  String?  @map("task_reference") @db.VarChar(255)
  description    String?  @db.Text
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([organizationId, createdAt])
  @@index([agentId])
  @@index([departmentId])
  @@map("ar_cost_entries")
}
```

### 1.2 File Structure

```
src/
  ar/                                    # AR Module Root
    index.ts                             # Module exports
    types.ts                             # Shared types

    organization/                        # Agent Organization
      ar-department.service.ts           # Department CRUD
      ar-position.service.ts             # Position CRUD
      ar-assignment.service.ts           # Assignment management
      ar-hierarchy.service.ts            # Org chart operations
      ar-cost.service.ts                 # Cost tracking

    api/                                 # REST API
      ar-departments.ts                  # Department endpoints
      ar-positions.ts                    # Position endpoints
      ar-assignments.ts                  # Assignment endpoints
      ar-org-chart.ts                    # Org chart visualization

    __tests__/                           # Tests
      ar-department.service.test.ts
      ar-position.service.test.ts
      ar-assignment.service.test.ts
```

### 1.3 Acceptance Criteria

- [ ] CRUD operations for departments, positions, assignments
- [ ] Hierarchical org chart query (returns tree structure)
- [ ] Cost tracking per agent/department with aggregation
- [ ] Audit log for all AR changes
- [ ] API endpoints with proper authorization
- [ ] Slack notifications for assignment changes

---

## Module 2: Human-Agent Approval Workflow

### 2.1 Multi-Level Approval Architecture

```
                    ┌─────────────────────────────────────────┐
                    │         APPROVAL LEVELS                  │
                    ├─────────────────────────────────────────┤
                    │                                         │
Level 5: OBJECTIVE  │  ← C-Level / Strategic decisions        │
     ↑              │    (Budget > $10K, Policy changes)      │
     │              │                                         │
Level 4: FUNCTION   │  ← Function Head (Marketing Head)       │
     ↑              │    (Cross-team, Budget $1K-$10K)        │
     │              │                                         │
Level 3: PROJECT    │  ← Project Owner / Manager              │
     ↑              │    (Project scope, Budget $100-$1K)     │
     │              │                                         │
Level 2: PROCESS    │  ← Team Lead / Senior Agent             │
     ↑              │    (Process deviation, Budget < $100)   │
     │              │                                         │
Level 1: TASK       │  ← Direct Supervisor / Auto-approve     │
                    │    (Routine tasks, Low risk)            │
                    └─────────────────────────────────────────┘
```

### 2.2 Database Schema

```prisma
/// AR Approval Request
model ARApprovalRequest {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  // Request details
  requestType    String   @db.VarChar(50)  // "task", "budget", "assignment", "schedule"
  level          Int      // 1-5 (Task to Objective)
  title          String   @db.VarChar(500)
  description    String   @db.Text
  context        Json     @default("{}") @db.JsonB
  impactScope    String?  @db.VarChar(50)  // "individual", "team", "department", "org"
  estimatedValue Int?     @map("estimated_value")  // In cents

  // Requester
  requesterType  String   @map("requester_type") @db.VarChar(20)  // "agent", "human"
  requesterId    String   @map("requester_id") @db.Uuid

  // Approver chain (computed at creation time)
  approverChain  Json     @map("approver_chain") @db.JsonB  // [{level, approverId, type}]
  currentLevel   Int      @default(1) @map("current_level")

  // Status
  status         String   @default("pending") @db.VarChar(50)
  responses      Json     @default("[]") @db.JsonB  // [{level, approverId, decision, note, timestamp}]

  // Timing
  expiresAt      DateTime @map("expires_at")
  escalationAt   DateTime? @map("escalation_at")  // When to auto-escalate

  // Slack integration
  slackChannelId String?  @map("slack_channel_id") @db.VarChar(50)
  slackMessageTs String?  @map("slack_message_ts") @db.VarChar(50)

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId, status])
  @@index([requesterId, requesterType])
  @@index([status, expiresAt])
  @@map("ar_approval_requests")
}

/// AR Escalation Rule
model ARApprovalRule {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  name           String   @db.VarChar(255)
  requestType    String   @db.VarChar(50)

  // Conditions
  conditions     Json     @db.JsonB  // {minValue, maxValue, impactScope, keywords}

  // Approval chain template
  requiredLevel  Int      @map("required_level")  // Minimum level required
  chainTemplate  Json     @map("chain_template") @db.JsonB  // How to build approver chain

  // Timing
  timeoutMinutes Int      @default(60) @map("timeout_minutes")
  autoEscalate   Boolean  @default(true) @map("auto_escalate")

  enabled        Boolean  @default(true)
  priority       Int      @default(0)  // Higher = checked first

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId, enabled])
  @@index([organizationId, requestType])
  @@map("ar_approval_rules")
}
```

### 2.3 File Structure

```
src/
  ar/
    approval/
      ar-approval.service.ts            # Core approval logic
      ar-approval-chain.service.ts      # Chain builder
      ar-approval-escalation.service.ts # Timeout & escalation
      ar-approval-rules.service.ts      # Rule management
      ar-approval-slack.service.ts      # Slack integration

    api/
      ar-approvals.ts                   # Approval endpoints
      ar-approval-rules.ts              # Rule management endpoints
```

### 2.4 Approval Flow

```typescript
// Approval request flow
interface ARApprovalFlow {
  // 1. Agent/Human creates request
  createRequest(input: {
    organizationId: string;
    requestType: 'task' | 'budget' | 'assignment' | 'schedule';
    title: string;
    description: string;
    context: Record<string, unknown>;
    requesterId: string;
    requesterType: 'agent' | 'human';
  }): Promise<ARApprovalRequest>;

  // 2. System determines approval chain based on rules
  buildApprovalChain(request: ARApprovalRequest): Promise<ApproverChain>;

  // 3. Notify approvers (Slack, Email, Dashboard)
  notifyApprovers(request: ARApprovalRequest, level: number): Promise<void>;

  // 4. Process response
  respond(requestId: string, decision: 'approved' | 'rejected', note?: string): Promise<void>;

  // 5. Auto-escalate on timeout
  escalateIfNeeded(requestId: string): Promise<void>;
}
```

### 2.5 Acceptance Criteria

- [ ] Multi-level approval chain builder
- [ ] Rule-based approval routing
- [ ] Slack interactive approval buttons
- [ ] Auto-escalation on timeout
- [ ] Approval history with audit trail
- [ ] API for managing approval rules
- [ ] Dashboard for pending approvals
- [ ] Notification via Slack DM

---

## Module 3: Autonomous Coordination Engine

### 3.1 Architecture

```
┌────────────────────────────────────────────────────────────────────┐
│                  AUTONOMOUS COORDINATION ENGINE                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐  │
│  │  Daily Report   │   │  Goal Alignment │   │  Priority       │  │
│  │  Aggregator     │   │  Analyzer       │   │  Optimizer      │  │
│  └────────┬────────┘   └────────┬────────┘   └────────┬────────┘  │
│           │                     │                     │            │
│           └─────────────────────┴─────────────────────┘            │
│                                 │                                   │
│                    ┌────────────▼────────────┐                     │
│                    │   Coordination          │                     │
│                    │   Decision Engine       │                     │
│                    └────────────┬────────────┘                     │
│                                 │                                   │
│           ┌─────────────────────┼─────────────────────┐            │
│           ▼                     ▼                     ▼            │
│  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐  │
│  │  Feedback       │   │  Issue          │   │  Rebalancing    │  │
│  │  Collector      │   │  Detector       │   │  Executor       │  │
│  └─────────────────┘   └─────────────────┘   └─────────────────┘  │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 3.2 Database Schema

```prisma
/// Agent Daily Report
model AgentDailyReport {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  agentId        String   @map("agent_id") @db.Uuid
  reportDate     DateTime @map("report_date") @db.Date

  // Activity summary
  tasksCompleted   Int    @default(0) @map("tasks_completed")
  tasksInProgress  Int    @default(0) @map("tasks_in_progress")
  tasksBlocked     Int    @default(0) @map("tasks_blocked")
  tokensConsumed   Int    @default(0) @map("tokens_consumed")
  avgResponseTime  Float? @map("avg_response_time")  // ms

  // Goal alignment
  goalAlignmentScore Float? @map("goal_alignment_score")  // 0-100
  contributedGoals   String[] @default([]) @map("contributed_goals") @db.Uuid

  // Issues & blockers
  blockers         Json   @default("[]") @db.JsonB  // [{description, severity, suggestedAction}]
  challenges       Json   @default("[]") @db.JsonB  // [{description, category}]

  // Recommendations
  recommendations  Json   @default("[]") @db.JsonB  // [{type, description, priority}]

  // AI-generated summary
  summaryText      String? @map("summary_text") @db.Text

  createdAt        DateTime @default(now()) @map("created_at")

  @@unique([organizationId, agentId, reportDate])
  @@index([organizationId, reportDate])
  @@index([agentId, reportDate])
  @@map("agent_daily_reports")
}

/// Department Daily Summary
model DepartmentDailySummary {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  departmentId   String   @map("department_id") @db.Uuid
  reportDate     DateTime @map("report_date") @db.Date

  // Aggregated metrics
  totalAgents       Int    @default(0) @map("total_agents")
  activeAgents      Int    @default(0) @map("active_agents")
  totalTasks        Int    @default(0) @map("total_tasks")
  completedTasks    Int    @default(0) @map("completed_tasks")
  avgGoalAlignment  Float? @map("avg_goal_alignment")
  totalCostCents    Int    @default(0) @map("total_cost_cents")

  // Department-level issues
  criticalBlockers  Json   @default("[]") @db.JsonB
  resourceShortages Json   @default("[]") @db.JsonB

  // AI analysis
  analysisText      String? @map("analysis_text") @db.Text
  priorityActions   Json    @default("[]") @map("priority_actions") @db.JsonB

  createdAt         DateTime @default(now()) @map("created_at")

  @@unique([organizationId, departmentId, reportDate])
  @@index([organizationId, reportDate])
  @@map("department_daily_summaries")
}

/// Goal Alignment Record
model GoalAlignmentRecord {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  agentId        String   @map("agent_id") @db.Uuid
  goalId         String   @map("goal_id") @db.Uuid

  alignmentScore Float    @map("alignment_score")  // 0-100
  contribution   String   @db.Text  // Description of contribution
  evidenceLinks  String[] @default([]) @map("evidence_links")  // Task IDs, etc.

  analysisDate   DateTime @map("analysis_date")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([organizationId, goalId])
  @@index([agentId, analysisDate])
  @@map("goal_alignment_records")
}

/// Workload Rebalancing Event
model WorkloadRebalancing {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  triggerType    String   @db.VarChar(50)  // "overload", "underutilized", "deadline_risk", "manual"
  triggerDetails Json     @db.JsonB

  // Changes made
  changes        Json     @db.JsonB  // [{agentId, action, from, to}]

  // Approval if needed
  approvalId     String?  @map("approval_id") @db.Uuid
  status         String   @default("pending") @db.VarChar(50)  // pending, approved, rejected, applied

  appliedAt      DateTime? @map("applied_at")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([organizationId, status])
  @@map("workload_rebalancing")
}
```

### 3.3 File Structure

```
src/
  ar/
    coordination/
      daily-report.service.ts           # Generate agent daily reports
      department-summary.service.ts     # Aggregate department summaries
      goal-alignment.service.ts         # Analyze goal alignment
      priority-optimizer.service.ts     # Optimize task priorities
      issue-detector.service.ts         # Detect blockers & challenges
      workload-rebalancer.service.ts    # Rebalance workloads
      coordination-engine.ts            # Main coordination orchestrator

    jobs/
      ar-daily-coordination.job.ts      # Scheduled daily coordination
      ar-realtime-monitor.job.ts        # Real-time monitoring
```

### 3.4 Coordination Flow

```
Daily Cycle:
┌──────────────────────────────────────────────────────────────────┐
│  06:00  │  Collect previous day's agent activity data            │
│  06:15  │  Generate individual agent reports                      │
│  06:30  │  Aggregate department summaries                         │
│  07:00  │  Run goal alignment analysis                            │
│  07:30  │  Detect issues & blockers                               │
│  08:00  │  Generate priority recommendations                      │
│  08:15  │  Send reports to department heads                       │
│  08:30  │  Present org-wide summary to leadership                 │
│  09:00  │  Apply approved rebalancing actions                     │
└──────────────────────────────────────────────────────────────────┘

Real-time Cycle (every 5 minutes):
┌──────────────────────────────────────────────────────────────────┐
│  Check for overloaded agents                                      │
│  Check for deadline risks                                         │
│  Check for blocked tasks > 1 hour                                 │
│  Auto-escalate if thresholds exceeded                             │
└──────────────────────────────────────────────────────────────────┘
```

### 3.5 Acceptance Criteria

- [ ] Daily report generation for all agents
- [ ] Department-level aggregation
- [ ] Goal alignment scoring algorithm
- [ ] Blocker detection with suggested actions
- [ ] Priority optimization recommendations
- [ ] Slack notifications for reports
- [ ] Dashboard visualization
- [ ] Real-time monitoring alerts

---

## Module 4: Schedule & Availability System

### 4.1 Architecture

```
┌────────────────────────────────────────────────────────────────────┐
│                SCHEDULE & AVAILABILITY SYSTEM                       │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                  Google Calendar Integration                 │   │
│  │   (Human calendars - meetings, vacations, availability)     │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                               │                                     │
│  ┌───────────────────────────▼─────────────────────────────────┐   │
│  │                 Availability Matrix                          │   │
│  │   Human availability + Agent capacity = Scheduling pool     │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                               │                                     │
│  ┌─────────────┬──────────────┴──────────────┬─────────────────┐   │
│  │             │                             │                 │   │
│  ▼             ▼                             ▼                 │   │
│ Meeting     Project                       Vacation            │   │
│ Scheduler   Date Optimizer               Coordinator          │   │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 4.2 Database Schema

```prisma
/// Human Availability (synced from calendar)
model HumanAvailability {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  userId         String   @map("user_id") @db.Uuid

  date           DateTime @db.Date
  availableFrom  String   @map("available_from") @db.VarChar(5)  // "09:00"
  availableUntil String   @map("available_until") @db.VarChar(5) // "18:00"
  timezone       String   @db.VarChar(50)

  // Status
  status         String   @db.VarChar(50)  // "available", "busy", "vacation", "sick"
  blockedSlots   Json     @default("[]") @db.JsonB  // [{from, to, reason}]

  // Sync info
  calendarSyncId String?  @map("calendar_sync_id") @db.VarChar(255)
  lastSyncAt     DateTime? @map("last_sync_at")

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@unique([organizationId, userId, date])
  @@index([organizationId, date])
  @@map("human_availability")
}

/// Agent Capacity (computed)
model AgentCapacity {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  agentId        String   @map("agent_id") @db.Uuid

  date           DateTime @db.Date
  maxTasks       Int      @default(10) @map("max_tasks")
  currentTasks   Int      @default(0) @map("current_tasks")
  maxTokens      Int      @default(100000) @map("max_tokens")
  usedTokens     Int      @default(0) @map("used_tokens")

  // Capacity score 0-100
  capacityScore  Float    @map("capacity_score")

  // Constraints
  blockedReasons Json     @default("[]") @db.JsonB  // [{reason, severity}]

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@unique([organizationId, agentId, date])
  @@index([organizationId, date])
  @@map("agent_capacity")
}

/// Scheduled Meeting (AR-aware meetings)
model ARMeeting {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  title          String   @db.VarChar(500)
  description    String?  @db.Text
  meetingType    String   @map("meeting_type") @db.VarChar(50)  // "standup", "review", "planning", "adhoc"

  // Participants
  humanParticipants String[] @default([]) @map("human_participants") @db.Uuid
  agentParticipants String[] @default([]) @map("agent_participants") @db.Uuid

  // Scheduling
  scheduledAt    DateTime @map("scheduled_at")
  durationMinutes Int     @map("duration_minutes")
  timezone       String   @db.VarChar(50)

  // Recurrence
  isRecurring    Boolean  @default(false) @map("is_recurring")
  recurrenceRule String?  @map("recurrence_rule") @db.VarChar(255)  // RRULE format

  // Calendar sync
  googleEventId  String?  @map("google_event_id") @db.VarChar(255)

  status         String   @default("scheduled") @db.VarChar(50)

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId, scheduledAt])
  @@index([status])
  @@map("ar_meetings")
}

/// Vacation/Leave Request
model ARLeaveRequest {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  // Who is taking leave
  entityType     String   @map("entity_type") @db.VarChar(20)  // "human", "agent"
  entityId       String   @map("entity_id") @db.Uuid

  leaveType      String   @map("leave_type") @db.VarChar(50)  // "vacation", "sick", "maintenance", "upgrade"

  startDate      DateTime @map("start_date") @db.Date
  endDate        DateTime @map("end_date") @db.Date

  reason         String?  @db.Text

  // Coverage planning
  coveringEntity String?  @map("covering_entity") @db.Uuid
  coveringType   String?  @map("covering_type") @db.VarChar(20)  // "human", "agent"
  handoverNotes  String?  @map("handover_notes") @db.Text

  // Approval
  approvalId     String?  @map("approval_id") @db.Uuid
  status         String   @default("pending") @db.VarChar(50)

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId, entityId])
  @@index([organizationId, startDate, endDate])
  @@map("ar_leave_requests")
}
```

### 4.3 File Structure

```
src/
  ar/
    scheduling/
      availability.service.ts           # Human availability sync
      capacity.service.ts               # Agent capacity management
      meeting-scheduler.service.ts      # Meeting coordination
      leave-manager.service.ts          # Vacation/leave handling
      calendar-sync.service.ts          # Google Calendar sync
      project-date-optimizer.service.ts # Project date coordination

    api/
      ar-availability.ts                # Availability endpoints
      ar-meetings.ts                    # Meeting endpoints
      ar-leave.ts                       # Leave request endpoints
```

### 4.4 Scheduling Intelligence

```typescript
// Smart scheduling rules
interface SchedulingRules {
  // "Tactful" scheduling - avoid conflicts
  rules: [
    {
      name: "avoid_lunch",
      description: "Don't schedule meetings during typical lunch hours",
      condition: (slot) => slot.hour >= 12 && slot.hour < 13,
      action: "deprioritize"
    },
    {
      name: "respect_focus_time",
      description: "Respect blocked focus time from calendars",
      condition: (slot, participant) => participant.blockedSlots.includes(slot),
      action: "exclude"
    },
    {
      name: "timezone_awareness",
      description: "Consider timezone differences for distributed teams",
      condition: (slot, participants) => !isReasonableForAll(slot, participants),
      action: "exclude"
    },
    {
      name: "leave_buffer",
      description: "Leave buffer between meetings",
      condition: (slot, calendar) => hasBackToBackMeeting(slot, calendar),
      action: "deprioritize"
    }
  ];
}
```

### 4.5 Acceptance Criteria

- [ ] Google Calendar bi-directional sync
- [ ] Availability matrix computation
- [ ] Smart meeting scheduling with conflict detection
- [ ] Leave request workflow with coverage planning
- [ ] Project date optimization
- [ ] Timezone-aware scheduling
- [ ] Slack notifications for schedule changes
- [ ] Dashboard for capacity visualization

---

## Module 5: Dynamic Team Templates

### 5.1 Architecture

```
┌────────────────────────────────────────────────────────────────────┐
│              DYNAMIC TEAM TEMPLATE SYSTEM                           │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Industry Best Practices DB                      │   │
│  │  (Tech startup, E-commerce, Fashion, Manufacturing, etc.)   │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                               │                                     │
│  ┌───────────────────────────▼─────────────────────────────────┐   │
│  │              Template Matching Engine                        │   │
│  │  (Org size, Industry, Growth stage, Goals → Templates)      │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                               │                                     │
│  ┌───────────────────────────▼─────────────────────────────────┐   │
│  │              Team Composition Engine                         │   │
│  │  (Template + Available agents → Optimal team)               │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 5.2 Database Schema

```prisma
/// Industry Template
model ARIndustryTemplate {
  id          String   @id @default(uuid()) @db.Uuid

  name        String   @db.VarChar(255)  // "Tech Startup - Early Stage"
  industry    String   @db.VarChar(100)  // "technology", "fashion", "ecommerce"
  companySize String   @map("company_size") @db.VarChar(50)  // "startup", "smb", "enterprise"
  growthStage String   @map("growth_stage") @db.VarChar(50)  // "seed", "growth", "mature"

  // Template structure
  departments Json     @db.JsonB  // [{name, description, positions: [...]}]
  keyRoles    Json     @map("key_roles") @db.JsonB  // Priority roles for this template

  // Recommended practices
  bestPractices Json   @map("best_practices") @db.JsonB
  antiPatterns  Json   @map("anti_patterns") @db.JsonB

  // Metrics
  usageCount   Int     @default(0) @map("usage_count")
  avgRating    Float?  @map("avg_rating")

  isBuiltIn    Boolean @default(false) @map("is_built_in")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([industry])
  @@index([companySize])
  @@map("ar_industry_templates")
}

/// Organization Team Configuration
model ARTeamConfiguration {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  name           String   @db.VarChar(255)  // "Project Alpha Team"
  templateId     String?  @map("template_id") @db.Uuid  // Base template

  // Custom configuration
  structure      Json     @db.JsonB  // Final team structure
  constraints    Json     @default("{}") @db.JsonB  // {maxBudget, maxAgents, requiredSkills}

  // Team members
  assignments    Json     @default("[]") @db.JsonB  // [{positionId, agentId, startDate}]

  // Project association
  projectId      String?  @map("project_id") @db.Uuid

  status         String   @default("active") @db.VarChar(50)

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId])
  @@index([templateId])
  @@map("ar_team_configurations")
}

/// Team Composition Recommendation
model ARTeamRecommendation {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  // Trigger
  triggerType    String   @map("trigger_type") @db.VarChar(50)  // "new_project", "scaling", "optimization"
  context        Json     @db.JsonB

  // Recommendations
  recommendations Json    @db.JsonB  // [{action, rationale, impact, effort}]

  // Matched templates
  matchedTemplates Json   @map("matched_templates") @db.JsonB  // [{templateId, matchScore}]

  status         String   @default("pending") @db.VarChar(50)
  appliedAt      DateTime? @map("applied_at")

  createdAt      DateTime @default(now()) @map("created_at")

  @@index([organizationId])
  @@map("ar_team_recommendations")
}
```

### 5.3 File Structure

```
src/
  ar/
    templates/
      industry-template.service.ts      # Template CRUD
      template-matcher.service.ts       # Match org to templates
      team-composer.service.ts          # Compose optimal teams
      recommendation-engine.service.ts  # Generate recommendations

    api/
      ar-templates.ts                   # Template endpoints
      ar-team-config.ts                 # Team configuration endpoints
      ar-recommendations.ts             # Recommendation endpoints

    data/
      built-in-templates/               # Pre-defined templates
        tech-startup.json
        fashion-brand.json
        ecommerce.json
        manufacturing.json
```

### 5.4 Built-in Templates Example

```json
{
  "name": "Fashion Brand - Growth Stage",
  "industry": "fashion",
  "companySize": "smb",
  "growthStage": "growth",
  "departments": [
    {
      "name": "Creative",
      "positions": [
        {"title": "Creative Director", "level": 5, "skills": ["design-direction", "brand-vision"]},
        {"title": "Senior Designer", "level": 3, "skills": ["fashion-design", "clo3d"], "count": 2},
        {"title": "Junior Designer", "level": 1, "skills": ["pattern-making"], "count": 3}
      ]
    },
    {
      "name": "Marketing",
      "positions": [
        {"title": "Marketing Lead", "level": 4, "skills": ["campaign-strategy", "analytics"]},
        {"title": "Content Creator", "level": 2, "skills": ["copywriting", "social-media"], "count": 2}
      ]
    },
    {
      "name": "Operations",
      "positions": [
        {"title": "Operations Manager", "level": 4, "skills": ["supply-chain", "vendor-management"]},
        {"title": "Quality Controller", "level": 2, "skills": ["quality-assurance"], "count": 2}
      ]
    }
  ],
  "bestPractices": [
    "Establish clear creative approval chain",
    "Maintain 1:3 senior to junior designer ratio",
    "Integrate quality control with design process"
  ]
}
```

### 5.5 Acceptance Criteria

- [ ] Built-in templates for 5+ industries
- [ ] Template matching algorithm
- [ ] Team composition optimizer
- [ ] Recommendation engine with rationale
- [ ] API for custom template creation
- [ ] Template import/export
- [ ] Dashboard for team visualization
- [ ] A/B testing for template effectiveness

---

## Module 6: AR Department Self-Management

### 6.1 Architecture

```
┌────────────────────────────────────────────────────────────────────┐
│                AR DEPARTMENT (Meta-Agents)                          │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      AR Director (Head)                      │   │
│  │   - Strategic AR decisions                                   │   │
│  │   - Organization-wide coordination                           │   │
│  │   - Executive reporting                                      │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                               │                                     │
│      ┌────────────────────────┼────────────────────────┐           │
│      │                        │                        │           │
│      ▼                        ▼                        ▼           │
│  ┌──────────┐            ┌──────────┐            ┌──────────┐     │
│  │ AR Ops   │            │ AR       │            │ AR       │     │
│  │ Manager  │            │ Analyst  │            │ Coach    │     │
│  │          │            │          │            │          │     │
│  │ - Agent  │            │ - Perf   │            │ - Agent  │     │
│  │   health │            │   metrics│            │   onboard│     │
│  │ - Infra  │            │ - Cost   │            │ - Skill  │     │
│  │   mgmt   │            │   optim  │            │   dev    │     │
│  └──────────┘            └──────────┘            └──────────┘     │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 6.2 AR Meta-Agent Definitions

```typescript
// AR Department Agent Definitions
const AR_META_AGENTS = {
  ar_director: {
    name: "AR Director",
    role: "Strategic AR leadership and organization-wide coordination",
    skills: ["strategic-planning", "executive-communication", "resource-allocation"],
    model: "opus",
    responsibilities: [
      "Review daily AR summaries and escalate issues",
      "Approve major organizational changes",
      "Generate executive AR reports",
      "Coordinate with human leadership"
    ]
  },

  ar_ops_manager: {
    name: "AR Operations Manager",
    role: "Day-to-day AR operations and agent health monitoring",
    skills: ["monitoring", "incident-response", "capacity-planning"],
    model: "sonnet",
    responsibilities: [
      "Monitor agent health and performance",
      "Handle infrastructure issues",
      "Manage agent lifecycle (hiring, retiring)",
      "Coordinate maintenance windows"
    ]
  },

  ar_analyst: {
    name: "AR Analyst",
    role: "Performance analysis, cost optimization, and metrics",
    skills: ["data-analysis", "reporting", "cost-optimization"],
    model: "sonnet",
    responsibilities: [
      "Generate performance reports",
      "Identify cost optimization opportunities",
      "Analyze workload patterns",
      "Benchmark agent effectiveness"
    ]
  },

  ar_coach: {
    name: "AR Coach",
    role: "Agent onboarding, skill development, and capability building",
    skills: ["training", "documentation", "skill-assessment"],
    model: "sonnet",
    responsibilities: [
      "Onboard new agents",
      "Develop training materials",
      "Assess and improve agent skills",
      "Maintain knowledge base"
    ]
  }
};
```

### 6.3 Database Schema

```prisma
/// AR Meta-Agent Definition
model ARMetaAgent {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  agentId        String   @map("agent_id") @db.Uuid  // Link to Agent table
  metaRole       String   @map("meta_role") @db.VarChar(50)  // "director", "ops_manager", etc.

  // Configuration
  config         Json     @default("{}") @db.JsonB
  schedule       Json     @default("{}") @db.JsonB  // When this meta-agent runs

  // Status
  status         String   @default("active") @db.VarChar(50)
  lastActiveAt   DateTime? @map("last_active_at")

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@unique([organizationId, metaRole])
  @@index([organizationId])
  @@map("ar_meta_agents")
}

/// AR Department Activity Log
model ARDepartmentLog {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  metaAgentId    String?  @map("meta_agent_id") @db.Uuid
  action         String   @db.VarChar(100)
  category       String   @db.VarChar(50)  // "monitoring", "analysis", "coaching", "coordination"

  details        Json     @db.JsonB
  impact         String?  @db.VarChar(50)  // "low", "medium", "high"

  createdAt      DateTime @default(now()) @map("created_at")

  @@index([organizationId, createdAt])
  @@index([category])
  @@map("ar_department_logs")
}
```

### 6.4 File Structure

```
src/
  ar/
    meta-agents/
      ar-director.agent.ts              # AR Director implementation
      ar-ops-manager.agent.ts           # Ops Manager implementation
      ar-analyst.agent.ts               # Analyst implementation
      ar-coach.agent.ts                 # Coach implementation
      meta-agent-orchestrator.ts        # Coordinates meta-agents

    api/
      ar-department.ts                  # AR Department endpoints
      ar-meta-agents.ts                 # Meta-agent management
```

### 6.5 Acceptance Criteria

- [ ] AR Director auto-reviews daily summaries
- [ ] AR Ops Manager monitors agent health
- [ ] AR Analyst generates weekly cost reports
- [ ] AR Coach onboards new agents
- [ ] Meta-agent coordination without conflicts
- [ ] Human override for all meta-agent decisions
- [ ] Audit log for all AR department actions
- [ ] Dashboard for AR department status

---

## ADDENDUM A: Concrete Scheduling Algorithm (Critic Issue #1)

### A.1 Scoring Algorithm Specification

The "tactful/flexible" scheduling system uses a weighted multi-factor scoring algorithm:

```typescript
// Concrete scoring algorithm for scheduling slots
interface SlotScore {
  slot: TimeSlot;
  score: number;  // 0-100 (higher = better)
  factors: ScoringFactor[];
  isExcluded: boolean;
  exclusionReason?: string;
}

interface ScoringFactor {
  name: string;
  weight: number;    // 0-1, all weights sum to 1
  rawScore: number;  // 0-100
  contribution: number;  // weight * rawScore
}

// Default weights (configurable per organization)
const DEFAULT_SCHEDULING_WEIGHTS = {
  participantAvailability: 0.35,   // Are all required participants free?
  workingHoursAlignment: 0.20,     // Is this during normal working hours?
  timezoneOptimization: 0.15,      // Is this reasonable for all timezones?
  bufferCompliance: 0.10,          // Does it have buffer from other meetings?
  focusTimeRespect: 0.10,          // Does it avoid blocked focus time?
  preferredTimeMatch: 0.10,        // Does it match user preferences?
};

// Scoring functions for each factor
const scoringFunctions = {
  participantAvailability: (slot: TimeSlot, participants: Participant[]) => {
    const availableCount = participants.filter(p => isAvailable(p, slot)).length;
    return (availableCount / participants.length) * 100;
  },

  workingHoursAlignment: (slot: TimeSlot, participant: Participant) => {
    const hour = slot.hour;
    const workStart = participant.workingHours?.start || 9;
    const workEnd = participant.workingHours?.end || 18;

    // Core hours (10-12, 14-16) = 100
    // Work hours but not core = 70
    // Early/late work hours = 40
    // Outside work hours = 0
    if (hour >= 10 && hour < 12 || hour >= 14 && hour < 16) return 100;
    if (hour >= workStart && hour < workEnd) return 70;
    if (hour >= workStart - 1 && hour < workEnd + 1) return 40;
    return 0;
  },

  timezoneOptimization: (slot: TimeSlot, participants: Participant[]) => {
    const localHours = participants.map(p => getLocalHour(slot, p.timezone));
    const allReasonable = localHours.every(h => h >= 7 && h <= 21);
    const allWorkHours = localHours.every(h => h >= 9 && h <= 18);

    if (allWorkHours) return 100;
    if (allReasonable) return 60;
    return 0;
  },

  bufferCompliance: (slot: TimeSlot, calendar: Calendar, bufferMinutes: number = 15) => {
    const meetingBefore = findMeetingBefore(slot, calendar);
    const meetingAfter = findMeetingAfter(slot, calendar);

    const bufferBefore = meetingBefore
      ? (slot.start.getTime() - meetingBefore.end.getTime()) / 60000
      : Infinity;
    const bufferAfter = meetingAfter
      ? (meetingAfter.start.getTime() - slot.end.getTime()) / 60000
      : Infinity;

    if (bufferBefore >= bufferMinutes && bufferAfter >= bufferMinutes) return 100;
    if (bufferBefore >= bufferMinutes / 2 && bufferAfter >= bufferMinutes / 2) return 50;
    return 0;
  },

  focusTimeRespect: (slot: TimeSlot, blockedSlots: BlockedSlot[]) => {
    const overlaps = blockedSlots.filter(b =>
      b.type === 'focus_time' && slotsOverlap(slot, b)
    );
    return overlaps.length === 0 ? 100 : 0;
  },

  preferredTimeMatch: (slot: TimeSlot, preferences: TimePreference[]) => {
    const matchingPref = preferences.find(p => matchesPreference(slot, p));
    if (!matchingPref) return 50;  // neutral if no preference
    return matchingPref.weight === 'preferred' ? 100 :
           matchingPref.weight === 'acceptable' ? 70 : 0;
  },
};
```

### A.2 Rule Conflict Resolution

When scheduling rules conflict, use priority-based resolution:

```typescript
interface SchedulingRule {
  id: string;
  name: string;
  priority: number;  // 1-100 (higher = more important)
  action: 'exclude' | 'deprioritize' | 'prefer';
  scorePenalty?: number;  // For 'deprioritize': reduce score by this amount
  condition: (slot: TimeSlot, context: SchedulingContext) => boolean;
}

// Conflict resolution algorithm
function resolveRuleConflicts(
  slot: TimeSlot,
  rules: SchedulingRule[],
  context: SchedulingContext
): { finalAction: string; reason: string } {

  const applicableRules = rules
    .filter(r => r.condition(slot, context))
    .sort((a, b) => b.priority - a.priority);

  if (applicableRules.length === 0) {
    return { finalAction: 'allow', reason: 'No rules apply' };
  }

  // If any 'exclude' rule with priority >= 80 applies, exclude
  const hardExclude = applicableRules.find(r => r.action === 'exclude' && r.priority >= 80);
  if (hardExclude) {
    return { finalAction: 'exclude', reason: hardExclude.name };
  }

  // If multiple deprioritize rules, accumulate penalties
  const deprioritizeRules = applicableRules.filter(r => r.action === 'deprioritize');
  if (deprioritizeRules.length > 0) {
    const totalPenalty = deprioritizeRules.reduce((sum, r) => sum + (r.scorePenalty || 10), 0);
    return {
      finalAction: 'deprioritize',
      reason: `${deprioritizeRules.map(r => r.name).join(', ')} (penalty: -${totalPenalty})`,
      penalty: totalPenalty
    };
  }

  // Highest priority 'prefer' wins
  const preferRule = applicableRules.find(r => r.action === 'prefer');
  if (preferRule) {
    return { finalAction: 'prefer', reason: preferRule.name };
  }

  return { finalAction: 'allow', reason: 'Default' };
}
```

### A.3 "눈치" (Nuanced Awareness) Learning

The system learns organizational scheduling patterns over time:

```typescript
interface SchedulingPattern {
  organizationId: string;
  patternType: 'time_preference' | 'participant_combo' | 'meeting_type_timing';

  // What the system learned
  observation: {
    description: string;
    evidence: {
      meetingId: string;
      outcome: 'successful' | 'rescheduled' | 'cancelled' | 'low_attendance';
    }[];
  };

  // How it affects scoring
  scoreModifier: {
    factor: string;
    adjustment: number;  // -20 to +20
    confidence: number;  // 0-1
  };

  // Minimum evidence required
  minOccurrences: number;  // default: 5
  lastUpdated: Date;
}

// Learning algorithm
async function updateSchedulingPatterns(
  organizationId: string,
  meeting: Meeting,
  outcome: MeetingOutcome
): Promise<void> {

  // Example pattern detection: "This team prefers afternoon meetings"
  if (outcome.type === 'successful' && outcome.attendanceRate > 0.9) {
    const hour = meeting.startTime.getHours();
    const participants = meeting.participants.map(p => p.id).sort().join(',');

    await upsertPattern({
      organizationId,
      patternType: 'participant_combo',
      key: `team_${participants}_prefers_${hour >= 12 ? 'afternoon' : 'morning'}`,
      observation: {
        description: `Team prefers ${hour >= 12 ? 'afternoon' : 'morning'} meetings`,
        evidence: [{ meetingId: meeting.id, outcome: 'successful' }]
      },
      scoreModifier: {
        factor: 'preferredTimeMatch',
        adjustment: +10,
        confidence: 0.5  // Increases with more evidence
      }
    });
  }

  // Pattern: "Meetings after this team's standup often get rescheduled"
  if (outcome.type === 'rescheduled') {
    // Track and learn from rescheduling patterns
    await trackReschedulingPattern(meeting, outcome);
  }
}
```

---

## ADDENDUM B: Real-Time Coordination Protocol (Critic Issue #2)

### B.1 Event-Driven Agent Roaming Architecture

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    REAL-TIME COORDINATION PROTOCOL                         │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐  │
│  │                     EVENT BUS (Redis Pub/Sub)                        │  │
│  │   Events: TASK_BLOCKED | OVERLOAD_DETECTED | DEADLINE_RISK |         │  │
│  │           RESOURCE_CONFLICT | APPROVAL_NEEDED | AGENT_IDLE           │  │
│  └───────────────────────────────┬─────────────────────────────────────┘  │
│                                   │                                        │
│         ┌─────────────────────────┼─────────────────────────┐             │
│         ▼                         ▼                         ▼             │
│  ┌──────────────┐          ┌──────────────┐          ┌──────────────┐    │
│  │ AR Roaming   │          │ AR Roaming   │          │ AR Roaming   │    │
│  │ Agent #1     │◄────────►│ Agent #2     │◄────────►│ Agent #N     │    │
│  │ (Designer Π) │ Negotiate │ (Ops Manager)│ Negotiate │ (Executor Φ) │    │
│  └──────┬───────┘          └──────┬───────┘          └──────┬───────┘    │
│         │                         │                         │             │
│         └─────────────────────────┼─────────────────────────┘             │
│                                   ▼                                        │
│                        ┌──────────────────┐                               │
│                        │   AR DIRECTOR    │                               │
│                        │ (Decision Maker) │                               │
│                        └──────────────────┘                               │
│                                                                            │
└──────────────────────────────────────────────────────────────────────────┘
```

### B.2 Coordination Event Types

```typescript
// Core event types for real-time coordination
type ARCoordinationEvent =
  | TaskBlockedEvent
  | OverloadDetectedEvent
  | DeadlineRiskEvent
  | ResourceConflictEvent
  | AgentIdleEvent
  | NegotiationRequestEvent
  | NegotiationResponseEvent
  | DirectorDecisionEvent;

interface TaskBlockedEvent {
  type: 'TASK_BLOCKED';
  taskId: string;
  blockedAgentId: string;
  blockerDescription: string;
  blockedSince: Date;
  urgency: 'low' | 'medium' | 'high' | 'critical';
  suggestedActions: SuggestedAction[];
}

interface NegotiationRequestEvent {
  type: 'NEGOTIATION_REQUEST';
  requestId: string;
  fromAgentId: string;
  toAgentId: string;
  requestType: 'task_handoff' | 'resource_share' | 'priority_swap' | 'workload_help';
  proposal: {
    description: string;
    benefit: string;
    cost: string;
  };
  expiresAt: Date;  // Auto-decline after expiration
}

interface NegotiationResponseEvent {
  type: 'NEGOTIATION_RESPONSE';
  requestId: string;
  fromAgentId: string;
  toAgentId: string;
  decision: 'accept' | 'reject' | 'counter';
  counterProposal?: {
    description: string;
    conditions: string[];
  };
  reason?: string;
}

interface DirectorDecisionEvent {
  type: 'DIRECTOR_DECISION';
  decisionId: string;
  context: {
    trigger: string;
    involvedAgents: string[];
    conflictingNegotiations?: string[];
  };
  decision: {
    action: string;
    assignments: { agentId: string; task: string }[];
    rationale: string;
  };
  effectiveAt: Date;
  requiresHumanApproval: boolean;
}
```

### B.3 Roaming Protocol State Machine

```typescript
// Agent coordination state machine
enum AgentCoordinationState {
  IDLE = 'IDLE',
  WORKING = 'WORKING',
  SEEKING_HELP = 'SEEKING_HELP',
  NEGOTIATING = 'NEGOTIATING',
  WAITING_DIRECTOR = 'WAITING_DIRECTOR',
  EXECUTING_DECISION = 'EXECUTING_DECISION',
}

interface AgentCoordinationContext {
  agentId: string;
  state: AgentCoordinationState;
  currentTask?: string;
  blockedReason?: string;
  activeNegotiations: string[];
  pendingDirectorDecisions: string[];
  lastStateChange: Date;
}

// State transitions
const coordinationTransitions: Record<AgentCoordinationState, Transition[]> = {
  IDLE: [
    { event: 'TASK_ASSIGNED', nextState: 'WORKING' },
    { event: 'NEGOTIATION_REQUEST', nextState: 'NEGOTIATING' },
  ],
  WORKING: [
    { event: 'TASK_COMPLETED', nextState: 'IDLE' },
    { event: 'TASK_BLOCKED', nextState: 'SEEKING_HELP' },
    { event: 'OVERLOAD_DETECTED', nextState: 'SEEKING_HELP' },
  ],
  SEEKING_HELP: [
    { event: 'NEGOTIATION_STARTED', nextState: 'NEGOTIATING' },
    { event: 'ESCALATED_TO_DIRECTOR', nextState: 'WAITING_DIRECTOR' },
    { event: 'BLOCKER_RESOLVED', nextState: 'WORKING' },
  ],
  NEGOTIATING: [
    { event: 'NEGOTIATION_SUCCEEDED', nextState: 'WORKING' },
    { event: 'NEGOTIATION_FAILED', nextState: 'WAITING_DIRECTOR' },
    { event: 'NEGOTIATION_TIMEOUT', nextState: 'WAITING_DIRECTOR' },
  ],
  WAITING_DIRECTOR: [
    { event: 'DIRECTOR_DECISION_RECEIVED', nextState: 'EXECUTING_DECISION' },
    { event: 'HUMAN_OVERRIDE', nextState: 'EXECUTING_DECISION' },
  ],
  EXECUTING_DECISION: [
    { event: 'EXECUTION_COMPLETE', nextState: 'WORKING' },
    { event: 'EXECUTION_FAILED', nextState: 'WAITING_DIRECTOR' },
  ],
};
```

### B.4 Negotiation Protocol

```typescript
// Agent-to-agent negotiation flow
async function initiateNegotiation(
  fromAgent: AgentContext,
  toAgent: AgentContext,
  request: NegotiationRequest
): Promise<NegotiationResult> {

  const negotiationId = generateNegotiationId();
  const NEGOTIATION_TIMEOUT_MS = 30000;  // 30 seconds

  // Step 1: Publish negotiation request
  await publishEvent({
    type: 'NEGOTIATION_REQUEST',
    requestId: negotiationId,
    fromAgentId: fromAgent.id,
    toAgentId: toAgent.id,
    requestType: request.type,
    proposal: request.proposal,
    expiresAt: new Date(Date.now() + NEGOTIATION_TIMEOUT_MS),
  });

  // Step 2: Wait for response (with timeout)
  const response = await waitForNegotiationResponse(negotiationId, NEGOTIATION_TIMEOUT_MS);

  if (!response) {
    // Timeout - escalate to director
    return await escalateToDirector(negotiationId, 'timeout');
  }

  // Step 3: Handle response
  if (response.decision === 'accept') {
    return { success: true, agreement: response };
  }

  if (response.decision === 'counter') {
    // Allow one counter-proposal round
    const counterResponse = await handleCounterProposal(
      fromAgent, toAgent, response.counterProposal
    );
    return counterResponse;
  }

  // Rejected - escalate to director
  return await escalateToDirector(negotiationId, 'rejected', response.reason);
}

// AR Director decision making
async function directorMakeDecision(
  escalation: EscalationContext
): Promise<DirectorDecision> {

  // Gather context
  const involvedAgents = await getAgentStates(escalation.involvedAgentIds);
  const workloadData = await getWorkloadDistribution(escalation.organizationId);
  const priorities = await getOrgPriorities(escalation.organizationId);

  // Decision factors
  const factors = {
    urgency: escalation.urgency,
    deadlineProximity: calculateDeadlineProximity(escalation),
    workloadBalance: assessWorkloadBalance(involvedAgents, workloadData),
    skillMatch: assessSkillMatch(escalation.task, involvedAgents),
    historicalSuccess: getHistoricalSuccessRates(involvedAgents, escalation.taskType),
  };

  // Make decision using weighted scoring
  const decision = weightedDecisionAlgorithm(factors, escalation.options);

  // Determine if human approval needed
  const requiresApproval =
    decision.impact === 'high' ||
    decision.costCents > 10000 ||
    escalation.conflictsWithHumanAssignments;

  return {
    decisionId: generateDecisionId(),
    action: decision.action,
    assignments: decision.assignments,
    rationale: decision.rationale,
    requiresHumanApproval: requiresApproval,
  };
}
```

---

## ADDENDUM C: Human-Agent Organization Linkage (Critic Issue #3)

### C.1 Human Position Schema

```prisma
/// Human Position (Role Definition for Humans)
model HumanPosition {
  id              String   @id @default(uuid()) @db.Uuid
  organizationId  String   @map("organization_id") @db.Uuid
  departmentId    String?  @map("department_id") @db.Uuid  // Can belong to agent department

  title           String   @db.VarChar(255)  // "VP Engineering", "Product Manager"
  level           Int      @default(1)  // 1-10 (higher = more senior)

  // AR Authority
  arApprovalLevel    Int   @default(0) @map("ar_approval_level")  // 0-5, what AR decisions can approve
  maxBudgetApproval  Int?  @map("max_budget_approval")  // Max budget (cents) can approve
  canOverrideAgents  Boolean @default(false) @map("can_override_agents")
  canAssignAgents    Boolean @default(false) @map("can_assign_agents")

  // Supervision scope
  supervisedDepartments String[] @default([]) @map("supervised_departments") @db.Uuid
  supervisedPositions   String[] @default([]) @map("supervised_positions") @db.Uuid

  metadata        Json     @default("{}") @db.JsonB
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  organization    Organization     @relation(fields: [organizationId], references: [id])
  assignments     HumanAssignment[]

  @@index([organizationId])
  @@index([departmentId])
  @@map("human_positions")
}

/// Human Assignment (User to Position mapping)
model HumanAssignment {
  id             String    @id @default(uuid()) @db.Uuid
  organizationId String    @map("organization_id") @db.Uuid
  userId         String    @map("user_id") @db.Uuid
  positionId     String    @map("position_id") @db.Uuid

  assignmentType String    @default("primary") @db.VarChar(50)  // primary, secondary, acting
  startDate      DateTime  @default(now()) @map("start_date")
  endDate        DateTime? @map("end_date")
  status         String    @default("active") @db.VarChar(50)

  // Delegation when absent
  delegateToId   String?   @map("delegate_to_id") @db.Uuid
  delegationReason String? @map("delegation_reason") @db.Text

  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  organization   Organization   @relation(fields: [organizationId], references: [id])
  user           User           @relation(fields: [userId], references: [id])
  position       HumanPosition  @relation(fields: [positionId], references: [id])

  @@unique([organizationId, userId, positionId])
  @@index([organizationId])
  @@index([userId])
  @@map("human_assignments")
}
```

### C.2 Agent-Human Approval Mapping

```typescript
// Mapping of AR actions to required human approvers
interface AgentActionApprovalMapping {
  actionCategory: ARActionCategory;
  actions: ARAction[];

  approvalRequirements: {
    // Condition-based approval routing
    conditions: ApprovalCondition[];
    defaultApprover: ApproverRole;
    escalationPath: ApproverRole[];  // If default unavailable
    timeoutMinutes: number;
    autoApproveIfTimeout: boolean;
  };
}

type ARActionCategory =
  | 'task_execution'
  | 'budget_spend'
  | 'external_communication'
  | 'data_modification'
  | 'agent_assignment'
  | 'policy_change'
  | 'emergency_action';

type ApproverRole =
  | 'direct_supervisor'
  | 'department_head'
  | 'function_owner'
  | 'project_manager'
  | 'budget_owner'
  | 'c_level'
  | 'ar_director'
  | 'security_officer';

// Comprehensive mapping table
const AGENT_ACTION_APPROVAL_MAP: AgentActionApprovalMapping[] = [
  {
    actionCategory: 'task_execution',
    actions: ['execute_routine_task', 'run_automation', 'process_data'],
    approvalRequirements: {
      conditions: [
        { if: 'impact_scope === "individual"', approver: 'auto_approve' },
        { if: 'impact_scope === "team"', approver: 'direct_supervisor' },
        { if: 'impact_scope === "department"', approver: 'department_head' },
        { if: 'impact_scope === "organization"', approver: 'function_owner' },
      ],
      defaultApprover: 'direct_supervisor',
      escalationPath: ['department_head', 'function_owner', 'c_level'],
      timeoutMinutes: 60,
      autoApproveIfTimeout: true,  // For low-risk task execution
    },
  },
  {
    actionCategory: 'budget_spend',
    actions: ['purchase', 'subscription', 'vendor_payment', 'resource_allocation'],
    approvalRequirements: {
      conditions: [
        { if: 'amount_cents <= 10000', approver: 'direct_supervisor' },
        { if: 'amount_cents <= 100000', approver: 'department_head' },
        { if: 'amount_cents <= 1000000', approver: 'budget_owner' },
        { if: 'amount_cents > 1000000', approver: 'c_level' },
      ],
      defaultApprover: 'budget_owner',
      escalationPath: ['c_level'],
      timeoutMinutes: 1440,  // 24 hours
      autoApproveIfTimeout: false,
    },
  },
  {
    actionCategory: 'external_communication',
    actions: ['send_email', 'post_social', 'publish_content', 'customer_contact'],
    approvalRequirements: {
      conditions: [
        { if: 'audience_size < 10', approver: 'direct_supervisor' },
        { if: 'audience_size < 1000', approver: 'department_head' },
        { if: 'audience_size >= 1000', approver: 'function_owner' },
        { if: 'is_press_release', approver: 'c_level' },
      ],
      defaultApprover: 'department_head',
      escalationPath: ['function_owner', 'c_level'],
      timeoutMinutes: 120,
      autoApproveIfTimeout: false,
    },
  },
  {
    actionCategory: 'agent_assignment',
    actions: ['reassign_agent', 'create_agent_position', 'modify_agent_permissions'],
    approvalRequirements: {
      conditions: [
        { if: 'scope === "same_department"', approver: 'department_head' },
        { if: 'scope === "cross_department"', approver: 'function_owner' },
        { if: 'is_permanent_change', approver: 'ar_director' },
      ],
      defaultApprover: 'ar_director',
      escalationPath: ['c_level'],
      timeoutMinutes: 240,
      autoApproveIfTimeout: false,
    },
  },
];
```

### C.3 Human Absence Escalation Path

```typescript
// Escalation when human approver is unavailable
interface EscalationPath {
  organizationId: string;

  // Who to contact in order when approver unavailable
  escalationLevels: EscalationLevel[];

  // Timeout between escalation attempts
  escalationTimeoutMinutes: number;

  // Final fallback
  finalFallback:
    | { type: 'auto_approve'; conditions: string[] }
    | { type: 'auto_reject'; reason: string }
    | { type: 'queue_for_return'; maxWaitHours: number };
}

interface EscalationLevel {
  level: number;
  approverSource:
    | 'delegate'           // Person's configured delegate
    | 'backup_position'    // Backup for this position
    | 'direct_manager'     // The person's manager
    | 'department_head'    // Head of department
    | 'any_with_level'     // Anyone with sufficient approval level
    | 'specific_role';     // Specific named role

  roleRequirements?: {
    minApprovalLevel: number;
    mustBeInDepartment?: boolean;
    mustHavePermission?: string;
  };
}

// Example escalation configuration
const DEFAULT_ESCALATION_PATH: EscalationPath = {
  organizationId: '*',  // Default for all orgs
  escalationLevels: [
    { level: 1, approverSource: 'delegate' },
    { level: 2, approverSource: 'backup_position' },
    { level: 3, approverSource: 'direct_manager' },
    {
      level: 4,
      approverSource: 'any_with_level',
      roleRequirements: { minApprovalLevel: 3, mustBeInDepartment: true }
    },
    { level: 5, approverSource: 'department_head' },
  ],
  escalationTimeoutMinutes: 30,
  finalFallback: {
    type: 'queue_for_return',
    maxWaitHours: 48,
  },
};

// Escalation algorithm
async function findAvailableApprover(
  request: ARApprovalRequest,
  primaryApprover: HumanAssignment,
  escalationPath: EscalationPath
): Promise<{ approver: User; level: number } | null> {

  // Check if primary is available
  const primaryAvailable = await isUserAvailable(primaryApprover.userId);
  if (primaryAvailable) {
    return { approver: await getUser(primaryApprover.userId), level: 0 };
  }

  // Walk escalation path
  for (const level of escalationPath.escalationLevels) {
    const candidates = await findCandidatesForLevel(
      request.organizationId,
      primaryApprover,
      level
    );

    for (const candidate of candidates) {
      if (await isUserAvailable(candidate.userId)) {
        return { approver: candidate, level: level.level };
      }
    }
  }

  // No one available - apply final fallback
  return null;
}
```

---

## ADDENDUM D: Template Learning Loop (Critic Issue #4)

### D.1 Template Effectiveness Tracking

```prisma
/// Template Effectiveness Metrics
model TemplateEffectivenessRecord {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid
  templateId     String   @map("template_id") @db.Uuid

  // Usage tracking
  usageStartDate DateTime @map("usage_start_date")
  usageEndDate   DateTime? @map("usage_end_date")

  // Outcome metrics
  taskCompletionRate     Float?  @map("task_completion_rate")       // 0-1
  avgGoalAlignmentScore  Float?  @map("avg_goal_alignment_score")   // 0-100
  avgAgentUtilization    Float?  @map("avg_agent_utilization")      // 0-1
  totalCostCents         Int?    @map("total_cost_cents")
  teamSatisfactionScore  Float?  @map("team_satisfaction_score")    // 0-10 (from surveys)

  // Comparative metrics
  comparedToBaseline     Float?  @map("compared_to_baseline")       // Performance vs no template
  comparedToAlternatives Json?   @map("compared_to_alternatives") @db.JsonB

  // Learning signals
  customizations         Json    @default("[]") @db.JsonB  // Changes made from template
  problemsEncountered    Json    @default("[]") @db.JsonB  // Issues during usage
  successPatterns        Json    @default("[]") @db.JsonB  // What worked well

  // Feedback
  userFeedback           Json    @default("[]") @db.JsonB  // Direct user feedback

  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  @@index([organizationId])
  @@index([templateId])
  @@map("template_effectiveness_records")
}

/// Template A/B Test
model TemplateABTest {
  id             String   @id @default(uuid()) @db.Uuid
  organizationId String   @map("organization_id") @db.Uuid

  name           String   @db.VarChar(255)
  description    String?  @db.Text

  // Test configuration
  templateA      String   @map("template_a") @db.Uuid
  templateB      String   @map("template_b") @db.Uuid

  // Split configuration
  splitRatio     Float    @default(0.5) @map("split_ratio")  // % going to template A
  targetMetric   String   @map("target_metric") @db.VarChar(100)  // Primary success metric
  secondaryMetrics String[] @default([]) @map("secondary_metrics")

  // Duration
  startDate      DateTime @map("start_date")
  endDate        DateTime? @map("end_date")
  minSampleSize  Int      @default(10) @map("min_sample_size")

  // Results
  status         String   @default("running") @db.VarChar(50)  // running, completed, cancelled
  results        Json?    @db.JsonB
  winningTemplate String? @map("winning_template") @db.Uuid
  statisticalSignificance Float? @map("statistical_significance")  // p-value

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@index([organizationId])
  @@index([status])
  @@map("template_ab_tests")
}
```

### D.2 Learning Loop Algorithm

```typescript
// Template learning and improvement system
interface TemplateLearningConfig {
  minDataPointsForLearning: number;  // Default: 10
  learningFrequency: 'daily' | 'weekly' | 'monthly';
  autoAdjustThreshold: number;  // Confidence threshold for auto-adjustments
  humanReviewThreshold: number; // Confidence threshold requiring human review
}

// Learning signals extracted from usage
interface TemplateLearningSignals {
  positionEffectiveness: {
    position: string;
    avgPerformance: number;
    suggestedAdjustment?: {
      type: 'increase_count' | 'decrease_count' | 'change_level' | 'add_skill' | 'remove';
      rationale: string;
      confidence: number;
    };
  }[];

  structuralInsights: {
    insight: string;
    evidence: string[];
    suggestedChange?: {
      description: string;
      priority: 'low' | 'medium' | 'high';
    };
  }[];

  organizationFit: {
    fitScore: number;  // 0-100
    mismatches: string[];
    adaptations: string[];
  };
}

// Main learning loop
async function runTemplateLearningCycle(templateId: string): Promise<void> {

  // Step 1: Gather effectiveness data
  const effectivenessRecords = await getEffectivenessRecords(templateId, {
    minAge: 30,  // At least 30 days of usage
    minCompleteness: 0.8,  // At least 80% of metrics filled
  });

  if (effectivenessRecords.length < 10) {
    logger.info('Insufficient data for learning', { templateId, records: effectivenessRecords.length });
    return;
  }

  // Step 2: Extract learning signals
  const signals = await extractLearningSignals(effectivenessRecords);

  // Step 3: Generate improvement suggestions
  const suggestions = await generateTemplateSuggestions(templateId, signals);

  // Step 4: Categorize by confidence
  const autoApplySuggestions = suggestions.filter(s => s.confidence >= 0.9);
  const humanReviewSuggestions = suggestions.filter(s => s.confidence >= 0.7 && s.confidence < 0.9);
  const experimentSuggestions = suggestions.filter(s => s.confidence < 0.7);

  // Step 5: Apply high-confidence changes (versioned)
  if (autoApplySuggestions.length > 0) {
    await applyTemplateChanges(templateId, autoApplySuggestions, { createVersion: true });
  }

  // Step 6: Queue human review suggestions
  if (humanReviewSuggestions.length > 0) {
    await createTemplateReviewRequest(templateId, humanReviewSuggestions);
  }

  // Step 7: Create A/B tests for low-confidence suggestions
  if (experimentSuggestions.length > 0) {
    await createTemplateExperiments(templateId, experimentSuggestions);
  }
}

// A/B test execution
async function assignTemplateForNewTeam(
  organizationId: string,
  context: TeamCreationContext
): Promise<{ templateId: string; isExperiment: boolean; testId?: string }> {

  // Check for active A/B tests
  const activeTests = await getActiveABTests(organizationId, context);

  if (activeTests.length > 0) {
    const test = activeTests[0];  // Use first applicable test
    const useA = Math.random() < test.splitRatio;

    await recordTestAssignment(test.id, context.teamId, useA ? 'A' : 'B');

    return {
      templateId: useA ? test.templateA : test.templateB,
      isExperiment: true,
      testId: test.id,
    };
  }

  // No active test - use best performing template
  const bestTemplate = await getBestTemplateForContext(organizationId, context);
  return { templateId: bestTemplate.id, isExperiment: false };
}
```

### D.3 Organization-Specific Customization

```typescript
// Organization customization layer on top of templates
interface OrganizationTemplateOverlay {
  organizationId: string;
  baseTemplateId: string;

  // Customizations
  positionOverrides: {
    originalPosition: string;
    override: Partial<PositionDefinition>;
  }[];

  additionalPositions: PositionDefinition[];
  removedPositions: string[];

  // Custom rules
  customSchedulingRules: SchedulingRule[];
  customApprovalRules: ApprovalRule[];

  // Learning preferences
  learningEnabled: boolean;
  autoApplyLearnings: boolean;
  maxAutoChangeLevel: 'minor' | 'moderate' | 'major';
}

// Apply organization customization
async function getEffectiveTemplate(
  organizationId: string,
  baseTemplateId: string
): Promise<EffectiveTemplate> {

  const baseTemplate = await getTemplate(baseTemplateId);
  const overlay = await getOrganizationOverlay(organizationId, baseTemplateId);

  if (!overlay) {
    return baseTemplate;
  }

  // Merge base template with overlay
  return mergeTemplateWithOverlay(baseTemplate, overlay);
}
```

---

## ADDENDUM E: Existing Service Integration (Critic Issue #5)

### E.1 Integration Mapping Table

| Existing Service | Location | AR Integration Point | Integration Method |
|-----------------|----------|---------------------|-------------------|
| `approval-checker.ts` | `src/services/approval-checker.ts` | AR approval requests route through | Extend `ApprovalType` enum, reuse `checkApprovalRequired()` |
| `auto-approval.service.ts` | `src/services/auto-approval.service.ts` | AR uses risk scoring for auto-approval | Extend `RequestType`, integrate `scoreApprovalRequest()` |
| `delegation-service.ts` | `src/services/delegation-service.ts` | Human-agent delegation mapping | Extend `DelegationScope` with AR scopes |
| `audit-logger.ts` | `src/services/audit-logger.ts` | All AR actions logged | Use existing `createAuditLog()` function |
| `Approval` model | `prisma/schema.prisma` | Link AR approvals to existing approvals | Add `arRequestId` field to Approval |

### E.2 ApprovalType Extension

```typescript
// Current ApprovalType in approval-checker.ts
export type ApprovalType = "budget" | "deployment" | "content" | "personnel" | "contract";

// Extended ApprovalType for AR
export type ExtendedApprovalType = ApprovalType
  | "ar_task"            // Agent task execution
  | "ar_assignment"      // Agent position assignment
  | "ar_schedule"        // Schedule/meeting changes
  | "ar_rebalancing"     // Workload rebalancing
  | "ar_department"      // AR department actions
  | "ar_meta_agent"      // Meta-agent decisions
  | "ar_emergency";      // Emergency agent actions

// Mapping AR requestType to existing ApprovalType
const AR_TO_APPROVAL_TYPE_MAP: Record<string, ApprovalType | ExtendedApprovalType> = {
  // AR types that map to existing
  'budget_allocation': 'budget',
  'agent_personnel_change': 'personnel',
  'external_publication': 'content',
  'system_deployment': 'deployment',

  // AR-specific types
  'task_execution': 'ar_task',
  'position_assignment': 'ar_assignment',
  'meeting_schedule': 'ar_schedule',
  'workload_change': 'ar_rebalancing',
  'department_action': 'ar_department',
  'meta_agent_action': 'ar_meta_agent',
  'emergency_override': 'ar_emergency',
};
```

### E.3 Integration with Auto-Approval Service

```typescript
// Extend existing auto-approval for AR requests
import {
  processApprovalRequest as existingProcessApprovalRequest,
  AutoApprovalResult
} from '../services/auto-approval.service';

// AR-specific auto-approval wrapper
export async function processARApprovalRequest(
  request: ARApprovalRequest
): Promise<AutoApprovalResult> {

  // Convert AR request to existing ApprovalRequest format
  const legacyRequest: ApprovalRequest = {
    id: request.id,
    organizationId: request.organizationId,
    userId: request.requesterId,  // Agent or human requester
    requestType: mapARToLegacyType(request.requestType),
    description: request.title,
    amount: request.estimatedValue,
    context: {
      ...request.context,
      arRequest: true,
      requesterType: request.requesterType,
      approvalLevel: request.level,
    },
  };

  // Use existing auto-approval logic
  const result = await existingProcessApprovalRequest(legacyRequest);

  // AR-specific post-processing
  if (result.autoApproved) {
    await logARAutoApproval(request, result);
    await notifyARStakeholders(request, result);
  }

  return result;
}

// AR-specific NEVER_AUTO_APPROVE additions
const AR_NEVER_AUTO_APPROVE: Set<string> = new Set([
  'ar_emergency',
  'ar_meta_agent',  // Meta-agent decisions always need approval
  'cross_department_transfer',
  'budget_over_threshold',
  'permanent_assignment_change',
]);
```

### E.4 Delegation Service Extension

```typescript
// Extend DelegationScope for AR
import { DelegationScope as BaseDelegationScope } from '../services/delegation-service';

export interface ARDelegationScope extends BaseDelegationScope {
  // AR-specific scope fields
  arActions?: string[];           // Allowed AR actions
  agentDepartments?: string[];    // Departments this delegation applies to
  maxAgentLevel?: number;         // Maximum agent level can manage
  canApproveAgentTasks?: boolean;
  canModifyAgentAssignments?: boolean;
  canAccessAgentMetrics?: boolean;
}

// AR delegation checker
export async function checkARDelegatedPermission(
  organizationId: string,
  userId: string,
  arAction: ARAction,
  resource: ARResource
): Promise<{ allowed: boolean; delegation?: Delegation }> {

  // First check existing delegation service
  const existingResult = await delegationService.checkUserHasDelegatedPermission(
    organizationId,
    userId,
    mapARActionToPermission(arAction),
    {
      type: resource.type,
      id: resource.id,
      amount: resource.estimatedValue,
    }
  );

  if (!existingResult.allowed) {
    return existingResult;
  }

  // Additional AR-specific checks
  const delegation = existingResult.delegation!;
  const arScope = delegation.scope as ARDelegationScope;

  // Check AR action is allowed
  if (arScope.arActions && !arScope.arActions.includes(arAction)) {
    return { allowed: false };
  }

  // Check department scope
  if (arScope.agentDepartments && resource.departmentId) {
    if (!arScope.agentDepartments.includes(resource.departmentId)) {
      return { allowed: false };
    }
  }

  // Check agent level
  if (arScope.maxAgentLevel && resource.agentLevel) {
    if (resource.agentLevel > arScope.maxAgentLevel) {
      return { allowed: false };
    }
  }

  return existingResult;
}
```

### E.5 Audit Logger Integration

```typescript
// AR-specific audit log wrapper
import { createAuditLog, auditLogger } from '../services/audit-logger';

export async function createARAuditLog(params: {
  organizationId: string;
  action: ARAuditAction;
  actorType: 'agent' | 'human' | 'system';
  actorId: string;
  resourceType: ARResourceType;
  resourceId: string;
  details: Record<string, unknown>;
  success: boolean;
  errorMessage?: string;
}): Promise<void> {

  // Use existing audit logger
  await createAuditLog({
    organizationId: params.organizationId,
    action: `ar.${params.action}`,
    userId: params.actorType === 'human' ? params.actorId : undefined,
    resourceType: `AR${params.resourceType}`,
    resourceId: params.resourceId,
    details: {
      ...params.details,
      actorType: params.actorType,
      actorId: params.actorId,
      isARAction: true,
    },
    success: params.success,
    errorMessage: params.errorMessage,
  });

  // Additional AR-specific logging if needed
  if (params.actorType === 'agent') {
    await logAgentAction(params);
  }
}

// AR audit action types
type ARAuditAction =
  | 'department.created' | 'department.updated' | 'department.deleted'
  | 'position.created' | 'position.updated' | 'position.deleted'
  | 'assignment.created' | 'assignment.updated' | 'assignment.terminated'
  | 'approval.requested' | 'approval.approved' | 'approval.rejected' | 'approval.escalated'
  | 'coordination.started' | 'coordination.completed' | 'coordination.failed'
  | 'meeting.scheduled' | 'meeting.rescheduled' | 'meeting.cancelled'
  | 'meta_agent.action' | 'meta_agent.decision';
```

---

## ADDENDUM F: Error Handling & Graceful Degradation

### F.1 Graceful Degradation Strategy

```typescript
// Degradation levels for AR system
enum ARDegradationLevel {
  FULL_OPERATION = 0,        // Everything works
  REDUCED_AUTOMATION = 1,    // Auto-approval disabled, manual only
  CORE_ONLY = 2,             // Only basic CRUD, no coordination
  READONLY = 3,              // Read operations only
  OFFLINE = 4,               // System unavailable
}

// Degradation triggers and responses
const DEGRADATION_TRIGGERS: DegradationTrigger[] = [
  {
    condition: 'redis_unavailable',
    degradeTo: ARDegradationLevel.REDUCED_AUTOMATION,
    fallbackBehavior: 'Route all approvals to manual queue',
  },
  {
    condition: 'google_calendar_api_error',
    degradeTo: ARDegradationLevel.CORE_ONLY,
    fallbackBehavior: 'Disable scheduling features, allow manual scheduling',
  },
  {
    condition: 'database_slow_queries',
    degradeTo: ARDegradationLevel.REDUCED_AUTOMATION,
    fallbackBehavior: 'Disable real-time monitoring, batch processing only',
  },
  {
    condition: 'llm_api_unavailable',
    degradeTo: ARDegradationLevel.CORE_ONLY,
    fallbackBehavior: 'Disable AI analysis, use rule-based decisions only',
  },
];

// Circuit breaker for external services
const AR_CIRCUIT_BREAKERS = {
  googleCalendar: new CircuitBreaker({
    failureThreshold: 5,
    resetTimeout: 60000,
    fallback: () => ({ available: false, reason: 'Calendar sync disabled' }),
  }),
  slackNotifications: new CircuitBreaker({
    failureThreshold: 3,
    resetTimeout: 30000,
    fallback: () => queueForRetry(),
  }),
};
```

### F.2 Redis Caching Strategy

```typescript
// AR caching configuration
const AR_CACHE_CONFIG = {
  // Organization structure (changes rarely)
  departments: { ttl: 3600, prefix: 'ar:dept:' },
  positions: { ttl: 3600, prefix: 'ar:pos:' },

  // Assignments (changes occasionally)
  agentAssignments: { ttl: 600, prefix: 'ar:assign:agent:' },
  humanAssignments: { ttl: 600, prefix: 'ar:assign:human:' },

  // Real-time data (short TTL)
  agentCapacity: { ttl: 60, prefix: 'ar:capacity:' },
  activeApprovals: { ttl: 30, prefix: 'ar:approval:active:' },
  coordinationState: { ttl: 10, prefix: 'ar:coord:state:' },

  // Computed/aggregated (invalidate on change)
  orgChart: { ttl: 1800, prefix: 'ar:orgchart:', invalidateOn: ['dept', 'pos', 'assign'] },
  approvalChains: { ttl: 900, prefix: 'ar:approvalchain:', invalidateOn: ['human', 'pos'] },
};

// Cache invalidation patterns
async function invalidateARCache(
  organizationId: string,
  changeType: 'dept' | 'pos' | 'assign' | 'human' | 'agent'
): Promise<void> {
  const keysToInvalidate: string[] = [];

  // Find affected caches
  for (const [cacheName, config] of Object.entries(AR_CACHE_CONFIG)) {
    if (config.invalidateOn?.includes(changeType)) {
      keysToInvalidate.push(`${config.prefix}${organizationId}:*`);
    }
  }

  // Batch invalidation
  if (keysToInvalidate.length > 0) {
    await redis.pipeline(
      keysToInvalidate.map(pattern => ['del', pattern])
    ).exec();
  }
}
```

---

## ADDENDUM G: Migration Strategy for Existing Tables

### G.1 Migration Plan

```typescript
// Migration sequence for AR tables
const AR_MIGRATION_SEQUENCE = [
  // Phase 1: Core structure (no data dependencies)
  {
    order: 1,
    migrations: [
      '20260201000001_create_agent_departments',
      '20260201000002_create_agent_positions',
      '20260201000003_create_human_positions',
    ],
    rollbackSafe: true,
  },

  // Phase 2: Assignments (depends on Phase 1)
  {
    order: 2,
    migrations: [
      '20260201000004_create_agent_assignments',
      '20260201000005_create_human_assignments',
      '20260201000006_add_ar_fields_to_approval',  // Extends existing Approval table
    ],
    rollbackSafe: true,
  },

  // Phase 3: AR-specific tables
  {
    order: 3,
    migrations: [
      '20260201000007_create_ar_approval_requests',
      '20260201000008_create_ar_approval_rules',
      '20260201000009_create_ar_cost_entries',
    ],
    rollbackSafe: true,
  },

  // Phase 4: Coordination tables
  {
    order: 4,
    migrations: [
      '20260201000010_create_agent_daily_reports',
      '20260201000011_create_department_daily_summaries',
      '20260201000012_create_goal_alignment_records',
      '20260201000013_create_workload_rebalancing',
    ],
    rollbackSafe: true,
  },

  // Phase 5: Scheduling tables
  {
    order: 5,
    migrations: [
      '20260201000014_create_human_availability',
      '20260201000015_create_agent_capacity',
      '20260201000016_create_ar_meetings',
      '20260201000017_create_ar_leave_requests',
    ],
    rollbackSafe: true,
  },

  // Phase 6: Templates and meta-agents
  {
    order: 6,
    migrations: [
      '20260201000018_create_ar_industry_templates',
      '20260201000019_create_ar_team_configurations',
      '20260201000020_create_ar_meta_agents',
      '20260201000021_create_template_effectiveness',
    ],
    rollbackSafe: true,
  },
];

// Safe migration with rollback
async function runARMigration(phase: number): Promise<void> {
  const phaseConfig = AR_MIGRATION_SEQUENCE.find(p => p.order === phase);
  if (!phaseConfig) throw new Error(`Invalid phase: ${phase}`);

  const transaction = await prisma.$transaction(async (tx) => {
    for (const migration of phaseConfig.migrations) {
      await runMigration(migration, tx);
    }
  });

  // Verify migration success
  await verifyMigrationHealth(phase);
}
```

---

## Task Flow and Dependencies

```
Phase 1: Foundation (Week 1-2)
├── T1.1: Database migrations for Module 1 [3 days]
├── T1.2: AR Organization services [2 days] (depends on T1.1)
├── T1.3: AR Organization API [1 day] (depends on T1.2)
└── T1.4: Basic Slack notifications [1 day] (parallel)

Phase 2: Approval System (Week 2-3)
├── T2.1: Database migrations for Module 2 [1 day]
├── T2.2: Approval chain builder [2 days] (depends on T2.1)
├── T2.3: Approval service [2 days] (depends on T2.2)
├── T2.4: Slack interactive approvals [2 days] (depends on T2.3)
└── T2.5: Escalation job [1 day] (depends on T2.3)

Phase 3: Coordination (Week 3-4)
├── T3.1: Database migrations for Module 3 [1 day]
├── T3.2: Daily report generator [2 days] (depends on T3.1)
├── T3.3: Goal alignment analyzer [2 days] (depends on T3.2)
├── T3.4: Priority optimizer [2 days] (depends on T3.3)
├── T3.5: Real-time monitor [1 day] (parallel)
└── T3.6: Coordination dashboard [2 days] (depends on T3.4)

Phase 4: Scheduling (Week 4-5)
├── T4.1: Database migrations for Module 4 [1 day]
├── T4.2: Calendar sync service [2 days] (depends on T4.1)
├── T4.3: Meeting scheduler [2 days] (depends on T4.2)
├── T4.4: Leave manager [1 day] (depends on T4.2)
└── T4.5: Capacity visualization [1 day] (depends on T4.3)

Phase 5: Templates (Week 5-6)
├── T5.1: Database migrations for Module 5 [1 day]
├── T5.2: Built-in templates [2 days] (depends on T5.1)
├── T5.3: Template matcher [2 days] (depends on T5.2)
├── T5.4: Team composer [2 days] (depends on T5.3)
└── T5.5: Recommendation engine [2 days] (depends on T5.4)

Phase 6: AR Department (Week 6-7)
├── T6.1: Database migrations for Module 6 [1 day]
├── T6.2: Meta-agent definitions [2 days] (depends on T6.1)
├── T6.3: Meta-agent orchestrator [2 days] (depends on T6.2)
└── T6.4: AR Department dashboard [2 days] (depends on T6.3)
```

---

## Commit Strategy

| Commit | Description | Module |
|--------|-------------|--------|
| `feat(ar): add database schema for organization structure` | Migration + models | 1 |
| `feat(ar): implement department service with hierarchy` | Service layer | 1 |
| `feat(ar): add position and assignment APIs` | API endpoints | 1 |
| `feat(ar): implement multi-level approval system` | Core approval | 2 |
| `feat(ar): add Slack interactive approval buttons` | Slack integration | 2 |
| `feat(ar): implement daily coordination engine` | Coordination | 3 |
| `feat(ar): add goal alignment scoring` | Analysis | 3 |
| `feat(ar): integrate Google Calendar for scheduling` | Calendar sync | 4 |
| `feat(ar): add meeting scheduler with smart rules` | Scheduling | 4 |
| `feat(ar): implement industry template system` | Templates | 5 |
| `feat(ar): add team composition optimizer` | Optimization | 5 |
| `feat(ar): implement AR meta-agents` | Self-management | 6 |
| `feat(ar): add AR department dashboard` | UI | 6 |

---

## Success Criteria

### Quantitative

| Metric | Target | Measurement |
|--------|--------|-------------|
| API Response Time | < 200ms p95 | Prometheus metrics |
| Agent Report Generation | < 30s for 100 agents | Job timing |
| Approval Chain Resolution | < 1s | Service timing |
| Calendar Sync Latency | < 5s | Integration metrics |
| Test Coverage | > 80% | Jest coverage report |

### Qualitative

| Criterion | Validation |
|-----------|------------|
| Human override always works | Manual testing |
| Slack notifications are clear | User feedback |
| Dashboard is intuitive | User feedback |
| Templates are relevant | Industry review |
| System degrades gracefully | Chaos testing |

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Schema migration failures | Medium | High | Staged migrations, backup strategy |
| Google Calendar API limits | Medium | Medium | Rate limiting, caching |
| Meta-agent conflicts | Low | Medium | Coordination protocol, locking |
| Performance at scale | Medium | High | Load testing, horizontal scaling |
| Complex approval chains | Medium | Medium | Chain visualization, debugging tools |

---

## Open Questions for Review

1. **Approval escalation timing**: Should escalation be configurable per organization or global?
   - **Addressed in Addendum C.3**: Default is per-organization with configurable `escalationTimeoutMinutes`

2. **Template versioning**: How do we handle template updates when teams are already using them?
   - **Addressed in Addendum D.2**: Version-controlled changes with `createVersion: true` flag

3. **Cost attribution**: Should costs be attributed to departments, projects, or both?
   - **Recommendation**: Both - `ARCostEntry` already supports both `departmentId` and `taskReference` for project-level tracking

4. **Human-agent ratio limits**: Should we enforce maximum agent-to-human ratios?
   - **Recommendation**: Soft limits with warnings, configurable per organization

5. **Cross-org AR sharing**: Will organizations ever share AR templates/agents?
   - **Addressed in Addendum D.3**: Templates can be shared via `isBuiltIn` flag, organization customization via overlay system

---

## Critic Feedback Resolution Summary

| Issue | Status | Resolution |
|-------|--------|------------|
| #1: Scheduling algorithm undefined | **RESOLVED** | Addendum A: Concrete scoring, conflict resolution, learning |
| #2: Real-time coordination missing | **RESOLVED** | Addendum B: Event-driven protocol, state machine, negotiation |
| #3: Human-agent linkage insufficient | **RESOLVED** | Addendum C: HumanPosition schema, approval mapping, escalation |
| #4: Template learning loop missing | **RESOLVED** | Addendum D: Effectiveness tracking, A/B testing, customization |
| #5: Existing service integration unclear | **RESOLVED** | Addendum E: Full integration mapping with code examples |
| Typo: `tokensCOnsumed` | **FIXED** | Corrected to `tokensConsumed` |
| Migration strategy missing | **RESOLVED** | Addendum G: Phased migration with rollback |
| Error handling missing | **RESOLVED** | Addendum F: Graceful degradation, circuit breakers |
| Redis caching strategy | **RESOLVED** | Addendum F.2: Complete caching configuration |

---

## Next Steps

After this plan is approved:

1. Run `/oh-my-claudecode:start-work ar-management-system` to begin implementation
2. Implementation will proceed phase-by-phase with feature flags
3. Each phase ends with a demo to stakeholders
4. Continuous integration tests run on each commit

---

**PLAN_READY: .omc/plans/ar-management-system.md**

---

*Iteration 2 completed. All Critic feedback has been addressed with concrete specifications.*
