# Phase 10: Monitoring & Operations - Specification

## Executive Summary

Complete implementation of monitoring and operations infrastructure for Nubabel, building on existing Prometheus metrics, basic OpenTelemetry, and Sentry to deliver distributed tracing, Grafana dashboards, health aggregation, and uptime monitoring.

---

## 1. Functional Requirements

### 1.1 OpenTelemetry Distributed Tracing
- Enhanced tracing with custom error-priority sampler (100% errors, 10% success)
- W3C trace context propagation across HTTP boundaries
- Auto-instrumentation for Express, Prisma, ioredis, BullMQ
- Custom spans for AI provider calls and MCP tool executions
- OTLP export to Jaeger (dev) / Grafana Tempo (prod)

### 1.2 Grafana Dashboards
- **System Overview**: DB/Redis latency, queue depth, circuit breaker states, memory/CPU
- **API Performance**: RPS, error rate, P50/P95/P99 latency, slow endpoints
- **Agent Operations**: Token usage by provider, execution duration, budget alerts
- JSON provisioning for automated deployment

### 1.3 Health Check Dashboard
- Aggregated `/health/full` endpoint with weighted scoring
- Component status: database, redis, queues, circuits, external APIs
- Summary metrics: requests/min, error rate, P95 latency

### 1.4 Sentry Integration Enhancement
- OTel-Sentry trace context linking via `@sentry/opentelemetry`
- Trace correlation between Sentry errors and OTel spans

### 1.5 Uptime Monitoring
- External uptime monitoring integration (Better Uptime/UptimeRobot)
- Status page webhook configuration
- Alerting to Slack/PagerDuty

---

## 2. Non-Functional Requirements

- Trace sampling overhead < 5ms per request
- Metrics collection interval: 5 seconds
- Health check response time < 500ms
- Dashboard load time < 3 seconds
- Zero data loss for error traces

---

## 3. Technical Architecture

### 3.1 New Files to Create

```
src/telemetry/
├── index.ts                    # Main telemetry initialization
├── tracing.ts                  # Enhanced OTel tracing setup
├── sampling.ts                 # Error-priority custom sampler
├── context-propagation.ts      # W3C trace context helpers
├── metrics-bridge.ts           # prom-client based metrics
└── sentry-integration.ts       # Sentry-OTel trace linking

src/api/
└── health-dashboard.ts         # /health/full endpoint

config/grafana/
├── dashboards/
│   ├── system-overview.json
│   ├── api-performance.json
│   └── agent-operations.json
└── provisioning/
    ├── datasources.yaml
    └── dashboards.yaml

config/alerting/
├── prometheus-rules.yaml
└── alerting-config.yaml

docker/
└── docker-compose.observability.yml
```

### 3.2 Files to Modify

| File | Changes |
|------|---------|
| `src/instrumentation.ts` | Import from `src/telemetry/tracing.ts` |
| `src/services/sentry.ts` | Add OTel trace linking |
| `src/services/metrics.ts` | Migrate to prom-client |
| `src/index.ts` | Import telemetry first, add `/health/full` route |
| `package.json` | Add new dependencies |

### 3.3 New Dependencies

```json
{
  "prom-client": "^15.1.0",
  "@sentry/opentelemetry": "^10.36.0"
}
```

---

## 4. Implementation Plan

### Phase A: Telemetry Foundation
1. Create `src/telemetry/` directory structure
2. Implement enhanced tracing (`tracing.ts`)
3. Implement error-priority sampler (`sampling.ts`)
4. Implement context propagation helpers (`context-propagation.ts`)
5. Update `src/instrumentation.ts` to use new telemetry

### Phase B: Metrics Migration
1. Create `src/telemetry/metrics-bridge.ts` with prom-client
2. Migrate `src/services/metrics.ts` to use prom-client internally
3. Preserve all existing metric recording functions

### Phase C: Sentry Integration
1. Add `@sentry/opentelemetry` dependency
2. Update `src/services/sentry.ts` with trace linking
3. Test error-trace correlation

### Phase D: Health Dashboard
1. Create `src/api/health-dashboard.ts`
2. Implement aggregated `/health/full` endpoint
3. Add weighted health scoring

### Phase E: Grafana Dashboards
1. Create `docker/docker-compose.observability.yml` (Jaeger + Grafana)
2. Create 3 dashboard JSON files
3. Create provisioning config files
4. Create Prometheus alert rules

### Phase F: Uptime Monitoring
1. Create uptime monitor configuration
2. Document external service setup
3. Add webhook endpoints if needed

---

## 5. Acceptance Criteria

- [ ] Traces appear in Jaeger with full request lifecycle
- [ ] All existing metrics preserved, /metrics works with Grafana
- [ ] 3 dashboards render correctly with live data
- [ ] /health/full returns aggregated status with correct scoring
- [ ] Sentry errors link to OTel traces
- [ ] Build passes with no TypeScript errors

---

*Generated by Autopilot Phase 0: Expansion*
*Date: 2026-01-29*
