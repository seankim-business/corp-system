import { Router, Request, Response } from "express";
import crypto from "crypto";
import { db as prisma } from "../db/client";
import { logger } from "../utils/logger";
import { orchestrationQueue } from "../queue/orchestration.queue";
import { getUserBySlackId, getOrganizationBySlackWorkspace } from "../services/slack-service";

const router = Router();

// ---------------------------------------------------------------------------
// Helper: Verify Slack request signature
// ---------------------------------------------------------------------------

function verifySlackSignature(
  signingSecret: string,
  signature: string,
  timestamp: string,
  body: string,
): boolean {
  // Reject requests older than 5 minutes to prevent replay attacks
  const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 60 * 5;
  if (parseInt(timestamp, 10) < fiveMinutesAgo) {
    logger.warn("Slack request timestamp too old", { timestamp });
    return false;
  }

  const sigBasestring = `v0:${timestamp}:${body}`;
  const hmac = crypto.createHmac("sha256", signingSecret);
  hmac.update(sigBasestring);
  const computedSignature = `v0=${hmac.digest("hex")}`;

  // Use timing-safe comparison to prevent timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(computedSignature, "utf-8"),
      Buffer.from(signature, "utf-8"),
    );
  } catch {
    // Buffers of different lengths will throw; treat as mismatch
    return false;
  }
}

// ---------------------------------------------------------------------------
// POST /api/slack/commands  -  Slash command handler (/nubabel)
// ---------------------------------------------------------------------------

router.post("/commands", async (req: Request, res: Response) => {
  try {
    const signingSecret = process.env.SLACK_SIGNING_SECRET;
    if (!signingSecret) {
      logger.error("SLACK_SIGNING_SECRET is not configured");
      return res.status(500).json({ error: "Slack integration not configured" });
    }

    // Slack sends these headers with every request
    const slackSignature = req.headers["x-slack-signature"] as string | undefined;
    const slackTimestamp = req.headers["x-slack-request-timestamp"] as string | undefined;

    if (!slackSignature || !slackTimestamp) {
      logger.warn("Missing Slack signature headers on /commands");
      return res.status(401).json({ error: "Missing Slack signature headers" });
    }

    // The raw body is needed for signature verification.
    // Express body-parser should expose it via req.body (url-encoded) or rawBody.
    // We reconstruct the url-encoded body string from the parsed fields.
    const rawBody =
      typeof (req as any).rawBody === "string"
        ? (req as any).rawBody
        : new URLSearchParams(req.body as Record<string, string>).toString();

    if (!verifySlackSignature(signingSecret, slackSignature, slackTimestamp, rawBody)) {
      logger.warn("Slack signature verification failed on /commands");
      return res.status(401).json({ error: "Invalid Slack signature" });
    }

    // Parse the slash-command payload (application/x-www-form-urlencoded)
    const {
      team_id: teamId,
      user_id: slackUserId,
      text: commandText,
      channel_id: channelId,
      response_url: responseUrl,
    } = req.body as Record<string, string>;

    logger.info("Slack slash command received", {
      teamId,
      slackUserId,
      channelId,
      commandText,
    });

    // Look up the Nubabel organization by Slack workspace
    const organization = await getOrganizationBySlackWorkspace(teamId);

    if (!organization) {
      logger.warn("No organization found for Slack workspace", { teamId });
      return res.status(200).json({
        response_type: "ephemeral",
        text: "Your Slack workspace is not connected to a Nubabel organization. Please visit Settings to connect.",
      });
    }

    const organizationId = organization.id;

    // Look up the Nubabel user by their Slack ID via the Slack API (email-based)
    const slackBotToken = process.env.SLACK_BOT_TOKEN;
    if (!slackBotToken) {
      logger.error("SLACK_BOT_TOKEN is not configured");
      return res.status(200).json({
        response_type: "ephemeral",
        text: "Slack bot token is not configured. Please contact your administrator.",
      });
    }

    const { WebClient } = await import("@slack/web-api");
    const slackClient = new WebClient(slackBotToken);
    const user = await getUserBySlackId(slackUserId, slackClient);

    if (!user) {
      logger.warn("No Nubabel user found for Slack user", { slackUserId, teamId });
      return res.status(200).json({
        response_type: "ephemeral",
        text: "Your Slack account is not linked to a Nubabel user. Please log in at https://nubabel.com and connect your Slack account.",
      });
    }

    const userId = user.id;

    if (!commandText || commandText.trim().length === 0) {
      return res.status(200).json({
        response_type: "ephemeral",
        text: "Usage: `/nubabel <your request>` — tell me what you need help with.",
      });
    }

    // Create a session ID for this command invocation
    const sessionId = crypto.randomUUID();

    // Queue the orchestration job
    const eventId = crypto.randomUUID();
    await orchestrationQueue.enqueueOrchestration({
      userRequest: commandText.trim(),
      sessionId,
      organizationId,
      userId,
      eventId,
      slackChannel: channelId,
      slackThreadTs: "",
    });

    logger.info("Slack command queued for orchestration", {
      sessionId,
      userId,
      organizationId,
      commandText: commandText.trim(),
    });

    // Immediate acknowledgment (ephemeral — only visible to the invoking user)
    return res.status(200).json({
      response_type: "ephemeral",
      text: `Got it! Processing your request: "${commandText.trim()}"\nI'll respond here shortly.`,
    });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    logger.error("Slack slash command handler error", { error: message });
    return res.status(200).json({
      response_type: "ephemeral",
      text: "Something went wrong processing your command. Please try again.",
    });
  }
});

// ---------------------------------------------------------------------------
// POST /api/slack/interactions  -  Interactive component handler
// ---------------------------------------------------------------------------

interface SlackInteractionPayload {
  type: string;
  user: { id: string; team_id: string };
  actions?: Array<{
    action_id: string;
    value?: string;
    block_id?: string;
  }>;
  trigger_id?: string;
  response_url?: string;
  message?: {
    ts: string;
    text?: string;
  };
  channel?: { id: string };
}

router.post("/interactions", async (req: Request, res: Response) => {
  try {
    const signingSecret = process.env.SLACK_SIGNING_SECRET;
    if (!signingSecret) {
      logger.error("SLACK_SIGNING_SECRET is not configured");
      return res.status(500).json({ error: "Slack integration not configured" });
    }

    const slackSignature = req.headers["x-slack-signature"] as string | undefined;
    const slackTimestamp = req.headers["x-slack-request-timestamp"] as string | undefined;

    if (!slackSignature || !slackTimestamp) {
      logger.warn("Missing Slack signature headers on /interactions");
      return res.status(401).json({ error: "Missing Slack signature headers" });
    }

    const rawBody =
      typeof (req as any).rawBody === "string"
        ? (req as any).rawBody
        : new URLSearchParams(req.body as Record<string, string>).toString();

    if (!verifySlackSignature(signingSecret, slackSignature, slackTimestamp, rawBody)) {
      logger.warn("Slack signature verification failed on /interactions");
      return res.status(401).json({ error: "Invalid Slack signature" });
    }

    // Slack sends interactive payloads as a JSON string in the 'payload' form field
    const payloadStr = req.body?.payload;
    if (!payloadStr || typeof payloadStr !== "string") {
      logger.warn("Missing or invalid payload in Slack interaction request");
      return res.status(400).json({ error: "Missing payload" });
    }

    let payload: SlackInteractionPayload;
    try {
      payload = JSON.parse(payloadStr) as SlackInteractionPayload;
    } catch {
      logger.warn("Failed to parse Slack interaction payload");
      return res.status(400).json({ error: "Invalid payload JSON" });
    }

    const slackUserId = payload.user?.id;
    const teamId = payload.user?.team_id;
    const actions = payload.actions ?? [];

    logger.info("Slack interaction received", {
      type: payload.type,
      slackUserId,
      teamId,
      actionCount: actions.length,
    });

    // Resolve the Nubabel organization and user
    const slackIntegration = teamId
      ? await prisma.slackIntegration.findUnique({
          where: { workspaceId: teamId },
        })
      : null;

    const organizationId = slackIntegration?.organizationId;

    for (const action of actions) {
      const actionId = action.action_id;
      const actionValue = action.value;

      try {
        // ----- Feedback actions -----
        if (actionId === "feedback_positive" || actionId === "feedback_negative") {
          const sentiment = actionId === "feedback_positive" ? "positive" : "negative";

          logger.info("Slack feedback received", {
            sentiment,
            slackUserId,
            actionValue,
            organizationId,
          });

          if (organizationId && actionValue) {
            // Store feedback as an audit log entry on the execution
            logger.info("Slack feedback saved", {
              sentiment,
              executionId: actionValue,
              organizationId,
              slackUserId: slackUserId ?? "unknown",
            });
          }
        }

        // ----- Approval actions -----
        else if (actionId === "approve_action" || actionId === "reject_action") {
          const status = actionId === "approve_action" ? "approved" : "rejected";

          logger.info("Slack approval action received", {
            status,
            slackUserId,
            actionValue,
          });

          if (actionValue) {
            const approval = await prisma.approval.findUnique({
              where: { id: actionValue },
            });

            if (!approval) {
              logger.warn("Approval not found for Slack action", {
                approvalId: actionValue,
              });
              continue;
            }

            if (approval.status !== "pending") {
              logger.info("Approval already responded", {
                approvalId: actionValue,
                currentStatus: approval.status,
              });
              continue;
            }

            if (new Date() > approval.expiresAt) {
              await prisma.approval.update({
                where: { id: actionValue },
                data: { status: "expired" },
              });
              logger.info("Approval expired", { approvalId: actionValue });
              continue;
            }

            await prisma.approval.update({
              where: { id: actionValue },
              data: {
                status,
                respondedAt: new Date(),
              },
            });

            logger.info("Approval updated via Slack interaction", {
              approvalId: actionValue,
              status,
              slackUserId,
            });
          }
        }

        // ----- Retry action -----
        else if (actionId === "retry_action") {
          logger.info("Slack retry action received", {
            slackUserId,
            actionValue,
          });

          if (actionValue && organizationId) {
            // actionValue is expected to contain the original job/session data as JSON
            let retryData: {
              userRequest: string;
              sessionId: string;
              userId: string;
            } | null = null;

            try {
              retryData = JSON.parse(actionValue) as {
                userRequest: string;
                sessionId: string;
                userId: string;
              };
            } catch {
              logger.warn("Failed to parse retry action value", {
                actionValue,
              });
            }

            if (retryData) {
              const sessionId = crypto.randomUUID();

              await addOrchestrationJob({
                userRequest: retryData.userRequest,
                sessionId,
                organizationId,
                userId: retryData.userId,
                metadata: {
                  source: "slack_retry",
                  originalSessionId: retryData.sessionId,
                  slackUserId,
                  slackChannelId: payload.channel?.id,
                  responseUrl: payload.response_url,
                },
              });

              logger.info("Retry job queued via Slack interaction", {
                sessionId,
                organizationId,
                originalSessionId: retryData.sessionId,
              });
            }
          }
        }

        // ----- Unknown action -----
        else {
          logger.warn("Unhandled Slack interaction action", {
            actionId,
            actionValue,
          });
        }
      } catch (actionError: unknown) {
        const actionMessage =
          actionError instanceof Error ? actionError.message : String(actionError);
        logger.error("Error handling Slack interaction action", {
          actionId,
          error: actionMessage,
        });
      }
    }

    // Slack requires a 200 OK response to acknowledge the interaction
    return res.status(200).send();
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    logger.error("Slack interaction handler error", { error: message });
    // Still return 200 to avoid Slack retrying indefinitely
    return res.status(200).send();
  }
});

export default router;
